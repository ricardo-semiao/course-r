[{"path":"index.html","id":"bem-vindo","chapter":"Bem Vindo!","heading":"Bem Vindo!","text":"Este livro tem o objetivo de ensinar linguagem R. O material tem duas especificidades principais: () é um livro para níveis diversos de experiência, é introdutório, mas expõe conceitos avançados e com profundidade; (ii) tem uma abordagem mista, primeiro focando na teoria, fundamentos, e funcionamento da linguagem, mas depois apresentando temas aplicados. Abaixo explico motivação para esse estilo, bem como para quem ele pode ser útil.este livro está em construção. O material aqui presente ainda é um rascunho, o estilo livro pode vir sofrer mudanças drásticas. Adicionalmente, precisão dos conceitos não está garantida.\nmomento, o iníco livro, até o capítulo 2, está relativamente em ordem.","code":""},{"path":"index.html","id":"por-que-este-livro","chapter":"Bem Vindo!","heading":"Por que Este Livro?","text":"Existem diferentes estilos de aprendizagem, alguns preferem “aprender fazendo”, outros preferem “aprender estudando”. Este livro é, em sua maior parte, signatário segundo. Porém, mesmo se esse não seu estilo preferido, argumento que ele combina com o estudo de R.R é uma linguagem única, para o bem e para o mal:Ela contém muitas exceções, particularidades, e heranças de outros tempos. Elas são causas comuns de erros e dificuldades de compreensão. Aprender regra, teoria, o contexto geral, facilita muito aprender lidar com exceções da maneira menos dolorosa possível.Ela contém ferramentas poderosas e incomuns. especialização em estatística motiva existência de construtos nada óbvios, mas muito úteis. Existe uma variedade de estilos (funcionais, orientado ao objeto, metalinguísticos) igualmente importantes, mas difíceis de alcançar sem um estudo mais teórico.Mas claro que o conhecimento aplicado também é quisto (deixemos o estudo teórico em si mesmo para os nerds da ciência da computação). Por isso, tento expor parte teórica da maneira mais tranquila e enxuta possível, focando essencial e deixando o extra como extra.Portanto, na segunda parte livro, foco em aplicar o conhecimento recém adquirido para aprender fazer duas tarefas mais comuns, presentes em basicamente todo projeto R, manipulação e visualização de dados. Mas sempre relacionando com os conceitos “teóricos” da ciência de dados.Por fim, na terceira parte, apresento aplicações variadas estilo “livro de receitas”. Aqui, existe muita intersecção com uma extensa literatura já existente, mas creio que vale muito pena aprender como aplicar todo o arcabouço visto antes em alguns dos tipos de projetos mais comuns.Antes de seguir adiante, uma palava motivacional: vezes uma pessoa passa mais tempo estudando um assunto que deveria, e quanto mais fundo vai, mais difícil é parar de estudar. Esse é o meu caso, mas gostaria de ter companhia nessa situação (ninguém é de ferro). Foi com isso em mente que montei esse material, para dar oportunidade leitor fazer o mesmo, da forma mais eficiente possível. Espero que goste!","code":""},{"path":"index.html","id":"organização-do-livro","chapter":"Bem Vindo!","heading":"Organização do Livro","text":"O livro é dividido em três partes: “R base”, “Ciência de Dados com o Tidyverse”, e “Aplicações Diversas”.bases desse material estão descritas na seção @(biblio), mas adianto o disclaimer: boa parte conteúdo deste livro é uma curadoria, simplificação, e adaptação dos materiais abaixo (organizados por parte):Primeira parte - R Language Definition, e Advanced R, 2nd Edition.Segunda parte - R Data Science, 2nd Edition, e tidyverse documentation.Terceira parte - R Cookbook, 2nd Edition, e Big Book R.","code":""},{"path":"index.html","id":"introdução","chapter":"Bem Vindo!","heading":"Introdução","text":"Para começar exponho alguns temas iniciais:história da linguagem, suas características gerais, porque aprender R.literatura sobre R, e referências deste livro.O estilo e didática livro.instalação e explicação da interface RStudio (de uma maneira bastante preguiçosa).","code":""},{"path":"index.html","id":"parte-i---r-base","chapter":"Bem Vindo!","heading":"Parte I - R base","text":"Os conceitos basilares R costumam ser ensinados rapidamente, para dar prioridade na manipulação de dados e aplicações. Esse curso não fará isso, iremos passar com bastante calma por essa dimensão, tanto porque existem menos tutoriais que fazem isso, mas principalmente, porque aprender sobre como o R funciona com detalhe gera uma série de benefícios:Permite entender códigos mais complexos.Permite aprender fontes comuns de erros e como evitá-las.Permite escrever códigos mais elegantes e principalmente mais eficientes.Facilitará explicação dos conceitos que empoderam o tidyverse.Essa abordagem é algo como ter aulas formais de uma língua, em oposição ensino para turismo. utilidade dessa abordagem depende de seu objetivo, se ele é “conseguir aplicar rapidamente novos conhecimentos”, outros livros serão mais úteis.","code":""},{"path":"index.html","id":"parte-ii---ciência-de-dados-com-o-tidyverse","chapter":"Bem Vindo!","heading":"Parte II - Ciência de Dados com o Tidyverse","text":"Na segunda parte, iremos aplicar os conhecimentos obtidos e linguagem desenvolvida para aprender sobre duas das tarefas mais comuns em aplicações R, manipulação e visualização de dados. Porém, ensino esses conceitas com base na “teoria” por trás de projetos de ciência de dados.Vamos executar essas tarefas R usando o framework tidyverse. Escolhi falar sobre ele, em oposição à usar o R base, ou outro framework, porque ele é um dos agregados de pacotes mais bem trabalhados, com uma sintaxe simples de entender, e que abrange todas etapas da manipulação de dados. Especialmente, os conceitos expostos na parte farão com que sua compreensão seja muito mais simples.","code":""},{"path":"index.html","id":"parte-ii---aplicações-diversas","chapter":"Bem Vindo!","heading":"Parte II - Aplicações Diversas","text":"parte três mostra como aplicar os conhecimentos adquiridos nas outras duas partes, em temas comuns. Já existe uma literatura extensa com objetivos similares, portanto, foco em temas mais centrais, e/ou que tenham um alto ganho de serem abordados com os frameworks e linguagem desenvolvida neste livro.Os temas são: problemas comuns da probabilidade e estatística, exploração de dados, modelagem de regressão, e modelagem de machine learning. Ao fim, listo referências para outras aplicações de possível interesse.","code":""},{"path":"index.html","id":"licença","chapter":"Bem Vindo!","heading":"Licença","text":"Esse material, como um todo, está licenciado pela Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.","code":""},{"path":"index.html","id":"contato","chapter":"Bem Vindo!","heading":"Contato","text":"Meu nome é Ricardo Semião, sou mestrando em economia na FGV-EESP, e sou fã de R. Se tiver algum comentário sobre este material, por favor mande em meu email ricardo.semiao@outlook.com. Minhas outras redes são:Github.Linkedin.StackOverflow.Twitter.","code":""},{"path":"introduction.html","id":"introduction","chapter":"Capítulo 1 Introdução","heading":"Capítulo 1 Introdução","text":"","code":""},{"path":"introduction.html","id":"história","chapter":"Capítulo 1 Introdução","heading":"1.1 História","text":"R é “uma linguagem de programação e um ambiente para computação estatística e gráfica”. Ela criada em 1993 por Ross Ihaka e Robert Gentleman da Universidade de Auckland, Nova Zelândia, com o apoio de John Chambers da Bell Laboratories. Foi inspirada na linguagem S, e por ser sua sucessora (e pela inicial dos autores), recebeu o nome R. Não, infelizmente, não é R de “Ricardo”.“Ambiente” sentido de que é uma linguagem de programação formal, um “sistema totalmente planejado e coerente”. Mas ainda assim, sendo especializada, com ferramentas poderosas e acessíveis para computação e visualização de projetos estatísticos ou da ciência de dados. Ao mesmo tempo, é facilmente incrementável, com centenas de extensões para mais diversas áreas.Entidades associadas ao desenvolvimento da linguagem:O Comprehensive R Archive Network (CRAN) foi criado em 1997 por Kurt Hornik e Fritz Leisch para armazenar o código fonte, documentação, e pacotes R.O R Core Team foi formado em 1997 para desenvolver linguagemA linguagem como projeto e homepage oficial é o R Project. Também existe homepage das versões em desenvolvimento R.R Foundation foi fundada em 2003 para guiar o R Project.O RStudio, agora Posit foi fundado para expandir qualidade projeto, lançando um ambiente de desenvolvimento integrado em 2011, e oferecendo soluções para empresas.O R Journal e R Blog.","code":""},{"path":"introduction.html","id":"características-da-linguagem-e-porque-r","chapter":"Capítulo 1 Introdução","heading":"1.2 Características da Linguagem, e “Porque R?”","text":"O R é uma linguagem bem específica. Abaixo cito algumas de suas características, e porque elas podem motivar seu estudo.R está disponível como código aberto, com sua licença GNU General Public License. Adicionalmente, é acessível para maioria das máquinas/sistemas operacionais. Isso faz com que projetos R sejam facilmente replicados por outros, e aumenta sua popularidade.R está disponível como código aberto, com sua licença GNU General Public License. Adicionalmente, é acessível para maioria das máquinas/sistemas operacionais. Isso faz com que projetos R sejam facilmente replicados por outros, e aumenta sua popularidade.R é uma linguagem popular, ficou na posição 21 TIOBE Index em fev/2024. Especialmente, ele conta com uma comunidade muito ativa e amigável, na #rstats Twitter, StackOverflow, Posit Community, e pessoalmente.R é uma linguagem popular, ficou na posição 21 TIOBE Index em fev/2024. Especialmente, ele conta com uma comunidade muito ativa e amigável, na #rstats Twitter, StackOverflow, Posit Community, e pessoalmente.Um produto dessa popularidade é quantidade massiva de extensões, para toda sorte de tarefa.\nExistem múltiplas abordagens para manipulação de dados, modelagem, e criação de visualizações.\nPoderosas ferramentas para comunicação, o RMarkdown (que foi utilizado para construir esse livro), e o Shiny, utilizado para construir Apps.\nFerramentas na fronteira de pesquisa, uma vez que pesquisadores costumam criar pacotes R para acompanhar sua pesquisa.\nUm produto dessa popularidade é quantidade massiva de extensões, para toda sorte de tarefa.Existem múltiplas abordagens para manipulação de dados, modelagem, e criação de visualizações.Poderosas ferramentas para comunicação, o RMarkdown (que foi utilizado para construir esse livro), e o Shiny, utilizado para construir Apps.Ferramentas na fronteira de pesquisa, uma vez que pesquisadores costumam criar pacotes R para acompanhar sua pesquisa.Ocupa um espaço muito interessante na paisagem de softwares:\nÉ uma linguagem de programação verdadeira, permitindo soluções para problemas mais complexos, e dando mais flexibilidade ao usuário, quando comparado com outros softwares estatísticos não programáticos como o SAS, SPSS, Stata, Eviews, e GRETL.\nMas é especializado, interpretada, e high-level, facilitando seu uso, e apresentando uma cuva de aprendizado mais rápida que linguagens mais complexas/generalistas como C, e talvez Python. \nOcupa um espaço muito interessante na paisagem de softwares:É uma linguagem de programação verdadeira, permitindo soluções para problemas mais complexos, e dando mais flexibilidade ao usuário, quando comparado com outros softwares estatísticos não programáticos como o SAS, SPSS, Stata, Eviews, e GRETL.Mas é especializado, interpretada, e high-level, facilitando seu uso, e apresentando uma cuva de aprendizado mais rápida que linguagens mais complexas/generalistas como C, e talvez Python. especialização em estatística faz com que ferramentas muito necessárias para análise de dados sejam de fácil acesso, como data-frames e vetorização. O usuário não precisa aprender extensões para realizar projetos em ciência de dados.especialização em estatística faz com que ferramentas muito necessárias para análise de dados sejam de fácil acesso, como data-frames e vetorização. O usuário não precisa aprender extensões para realizar projetos em ciência de dados.Algumas características mais técnicas:\nSua sintaxe é similar à C e Python, mas sua semântica é de uma linguagem funcional, mais similar à Lisp e APL. Veremos que o estilo funcional é muito útil para projetos de ciência de dados.\nAlém das funcionais, R tem capacidades incomuns de metaprogramação, permitindo códigos elegantes e sucintos.\nNão é seu forte, mas também conta com algumas ferramentas de programação orientada ao objeto, facilitando vida usuário.\nO R usa código em C, C++, e Fortran para executar tarefas computacionalmente intensivas. Isso é algo que o usuário também pode explorar.\nAlgumas características mais técnicas:Sua sintaxe é similar à C e Python, mas sua semântica é de uma linguagem funcional, mais similar à Lisp e APL. Veremos que o estilo funcional é muito útil para projetos de ciência de dados.Além das funcionais, R tem capacidades incomuns de metaprogramação, permitindo códigos elegantes e sucintos.Não é seu forte, mas também conta com algumas ferramentas de programação orientada ao objeto, facilitando vida usuário.O R usa código em C, C++, e Fortran para executar tarefas computacionalmente intensivas. Isso é algo que o usuário também pode explorar.Porém, nem tudo são flores. Muitas dessas características tem prós e contras, e execução dessas ideias conta com heranças obsoletas e inconsistências. Neste livro, deixarei claro os pontos negativos mais importantes, e ensino evitá-los.","code":""},{"path":"introduction.html","id":"biblio","chapter":"Capítulo 1 Introdução","heading":"1.3 Literatura sobre R","text":"literatura base pode ser encontrada CRAN. Ela é composta de, principalmente:O código fonte (R Core Team 2024c).O manual “R Language Definition” (R Core Team 2024e), que descreve linguagem em si.O manual “R Internals” (R Core Team 2024d), que descreve estruturas internas R, e fundação código em C.documentação de ajuda para o R base e extensões padrões (R Core Team 2024f).documentação de ajuda para extensões externas (R Core Team 2024b).Nenhuma dessas é exatamente didática, mas existe uma vasta bibliografia de livros para R, tanto para ensinar linguagem geral, quanto para toda sorte de aplicações. Abaixo alguns exemplos mais recentes, divididos pela sua relação com cada parte deste livro.Bibliografia base da parte : o livro “Advanced R” (segunda edição) (Hadley Wickham 2019), junto com “R Language Definition”.Outros livros introdutórios:\n“Introduction R” (R Core Team 2024a) (manual oficial).\n“Working R” (Stephanie Locke 2017b).\n“Introduction R” (Longhow Lam 2010).\n“Introduction R” (R Core Team 2024a) (manual oficial).“Working R” (Stephanie Locke 2017b).“Introduction R” (Longhow Lam 2010).Livros para ciência de dados, mas com introdução extensa: “R Programming Data Science”, “Modern R Tidyverse”.Livro complementar, com abordagem “aprender fazendo”: “Hands Programming R” (Garrett Grolemund 2014)Bibliografia base da parte II: o livro “R Data Science” (Hadley Wickham Garrett Grolemund 2024) e documentações dos pacotes tidyverse (“Tidyverse,” n.d.).Outros livros sobre manipulação e visualização de dados:\n“STAT 545”.\n“Data Manipulation R” (Stephanie Locke 2017a).\n“ggplot2: Elegant Graphics Data Analysis” (Hadley Wickham, Danielle Navarro, Thomas Lin Pedersen 2010).\n“Data Wrangling Recipes R” (Hilary Watt, n.d.).\n“STAT 545”.“Data Manipulation R” (Stephanie Locke 2017a).“ggplot2: Elegant Graphics Data Analysis” (Hadley Wickham, Danielle Navarro, Thomas Lin Pedersen 2010).“Data Wrangling Recipes R” (Hilary Watt, n.d.).Livro complementar, com abordagem “aprender fazendo”: “Introduction Data Exploration Analysis R” (Michael Mahoney 2019).Bibliografia base da parte III: o livro “R Cookbook” (segunda edição) (Hadley Wickham 2019), e o livro “Big Book R” (Oscar Baruffa 2024).Existem muitos outros livros e tutoriais dedicados aplicações específicas. Algumas listas (incompletas) podem ser encontradas arquivo CRAN.","code":""},{"path":"introduction.html","id":"estilo-do-livro","chapter":"Capítulo 1 Introdução","heading":"1.4 Estilo do Livro","text":"Antes de prosseguir, quero expor de antemão o estilo e organização dos capítulos.Este livro tem muito cobrir, e tem um andamento acelerado. Para facilitar ao máximo vida leitor, o estilo dos capítulos foi definido para ajudar direcionar atenção para o que é mais importante, e menos atenção para o extra. Abaixo apresento alguns dos construtos utilizados para tal.Pequenos excertos de código são apresentados na linha 1 + 1, e blocos de código como abaixo.Nos exemplos deste livro, um comentário formato #> ... indica o resultado esperado da declaração que o precede.“Nome” resultado\nResultados importantes são expostos neste tipo de bloco. Note que nem todos os resultados serão simples de entender imediatamente, mas são expostos momento em que é relevante para o estudo da linguagem.Palavras em negrito: normalmente indicam conceitos que serão definidos. Após sua apresentação, os conceitos costumam deixar de aparecer em negrito.Palavras em itálico costumam ser palavras com utilizadas com um significado específico contexto relevante, mas não necessariamente “conceitos”. Em contrapartida, vezes uso aspas para indicar uma palavra sendo utilizada pelo seu significado em português, e não como um conceito da programação. Porém, cuidado, vezes aspas tem seu uso padrão, e itálico é usado para palavras em inglês.vezes é importante apresentar um exemplo para esclarecer um conceito. Tendo colocar exemplos apenas quando necessário, de modo que é importante entendê-los. Em contrapartida, não há muitos exemplos “complementares”. É natural que essa baixa frequência torne difícil compreensão de alguns temas. Mas para isso existem os exercícios.nesse bloco explicito pontos que o leitor deve prestar atenção. Na maioria dos casos, apresento causas comuns de erros.observações deste tipo costumam ser sobre organização livro ou outros esclarecimentos menos importantes.nesse tipo de bloco apresento referências que tratam tema relevante com mais calma, ou trazem tópicos adicionais para o leitor que queira expandir seus conhecimentos.Itens de lista isolados costumam trazer comentários menos importantes.Ao final de cada capítulo existe uma seção de “Complemento”. Nele, há:Uma recapitulação dos conceitos apresentados.Uma lista de exercícios, que pode, inclusive, apresentar novos conceitos/funções.Uma lista de funções apresentadas capítulo.Uma seção de referências, inclusive com links para conceitos deixados de lado capítulo, para o leitor que quiser ir além.","code":"\nx <- 1 + 1\nx*2 #> 4"},{"path":"introduction.html","id":"instalação-interface-e-ferramentas","chapter":"Capítulo 1 Introdução","heading":"1.5 Instalação, Interface, e Ferramentas","text":"Antes de começar o aprendizado, é preciso instalar linguagem (R), e se familiarizar com interface editor de código oficial (RStudio).Veja como instalar neste tutorial curso “R Para Jornalistas”. PS: coincidentemente, maneira que jornalistas instalam o R serve para qualquer outra profissão também.Existem vários tutoriais online explicando interface, como o da Datacamp (veja até “Write R Scripts RStudio”) e este video “RStudio Total Beginner”.Além disso, existem três configurações mais comuns de serem alteradas: alterar onde os arquivos são salvos por padrão (figura 1, “browse”); impedir que os dados da última vez que você entrou R sejam recarregados quando você voltar (figura 1, “workspace”); e alterar aparência (figura 2). Todas elas podem ser encontradas na tab Tools > Global Options:vide (Stephanie Locke 2017b), capítulo “3 - Using RStudio”, e/ou (James Long Paul Teetor 2019), 3 - “Navigating Software”, para mais informações sobre interface.Até o momento, eu fui preguiçoso e não trouxe esse material para o livro. Ainda assim, veja referências com calma, não deixe confusões com o software atrapalharem seu aprendizado.Última coisa, eu juro. O R provê alguns comandos para procurar por ajuda. função vignette() abre uma lista de artigos de ajuda das extensões R. Adicionalmente, se você quer saber informações sobre uma função chamada “acaba_pelo_amor_de_deus”, os códigos abaixo abrem suas documentações de ajuda. Vejam mais sobre aqui, e aqui.Agora sim, vamos começar. Boa sorte!","code":"\n?acaba_pelo_amor_de_deus\nhelp(\"acaba_pelo_amor_de_deus\")"},{"path":"intro1.html","id":"intro1","chapter":"Parte I - R Base","heading":"Parte I - R Base","text":"Bem vindo à primeira parte deste livro, onde estudaremos os conceitos na base R. Partirei zero absoluto, de modo que é possível que o leitor tenha algum nível de familiaridade com os temas, mas provavelmente, não na profundidade aqui abordada.Nessa parte mais “teórica”, é difícil de traçar o limite nível de complexidade ideal. Por conta disso, muitos conceitos tiveram de ser introduzidos rapidamente. Mas não se assuste, muitas vezes, meu objetivo maior é passar uma intuição geral de como o R funciona, e dar um primeiro contato com os temas mais complexos. Tento ao máximo deixar claro onde gastar seu cérebro e onde nem tanto.Meu foco é mostrar lógica R, “sintaxe e semântica” da linguagem. “gramática/vocabulário”, isto é, funções, truques, e aplicações específicas, serão ensinadas de passagem e via exercícios. Mas final, ideia é ter apresentado maioria das funções comumente relevantes, construindo uma lista de referência para futuras consultas.Os capítulos dessa seção estão organizados da seguinte maneira:Capítulo 2: aqui aprenderemos o básico sobre sintaxe R. Como imputar números e texto, o que são expressões e variáveis, e como realizar operações básicas. geral, um capítulo bastante simples.Capítulo 3: organização de tipos de dados R é elegantemente simples, incluindo complexidade através da existência de metadados. principal conclusão será entender relação entre os diferentes tipos, porque esse conhecimento torna mais fácil pensar como uma mesma operação é aplicada em cada tipo de dado.Capítulo 4: nessa altura campeonato, capaz que você esteja cansado de ver apenas teoria, esse capítulo é o mais “gramatical” de todos. Aprenderemos o que é operação de selecionar e alterar partes de uma variável. Aqui, já fica claro o benefício de entender organização dos tipos de dados.Capítulo 5: aprenderemos controlar o fluxo de um programa, isto é, como fazer um programa tomar decisões e repetir operações. Aprenderemos também lidar com erros e avisos.Capítulo 6: em oposição ao capítulo 3, agora é hora de dar atenção aos sentimentos R. Estávamos utilizando-, mas não explicamos o que são funções. Esse é o capítulo mais desafiador, mas boa parte da dificuldade pode ser deixada de lado, com perdas reduzidas ao leitor.Capítulo 7: aqui, aprenderemos sobre os paradigmas/estilos de programação funcional, orientada ao objeto, e meta, especificamente sobre sua abordagem R. programação funcional é uma ferramenta com ligação direta nos projetos de ciência de dados; Entender o básico de POO R é importante para entender o uso de funções[^Se chutou “objetos”, chutou errado.]; Metaprogramação é um assunto útil em si mesmo, mas especialmente importante para entender bases tidyverse na segunda parte livro.Capítulo 8: por fim, temos algum outros tópicos úteis, mas não essenciais para o seguimento livro. Aqui, aprenderemos sobre algumas ferramentas de melhoria de vida que o RStudio provê, e alguns temas avançados sobre gerenciamento de memória, performance, e organização.Recapitulado: não só em cada capítulo, mas cada parte deste livro, existe uma seção para retomar os conteúdos, especialmente o que será mais útil para próxima parte.","code":""},{"path":"syntax-vars.html","id":"syntax-vars","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Capítulo 2 Sintaxe e Variáveis","text":"","code":""},{"path":"syntax-vars.html","id":"sintaxe","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.1 Sintaxe","text":"Em termos simplistas, um script é um arquivo de texto com instruções serem executadas por um computador que antes traduzirá o arquivo para linguagem de máquina.Um script é um texto instrucional como qualquer outro, escrito em um tipo de linguagem especial, “de programação”, ou “código”, mas é um texto. Pode similar à receita de bolo de cenoura da minha vó, ou o roteiro da peça escolar onde interpretei, com maestria, árvore #3.Como em qualquer linguagem, temos um vocabulário à disposição, um conjunto de palavras (ou tokens) existentes, organizadas em categorias como substantivos, adjetivos, etc. Nós combinamos palavras em frases (ou statements) para descrever instruções. Por fim, organizamos o texto em parágrafos (ou blocks), conjuntos de frases que devem ser lidas juntas, para definir estrutura e facilitar o entendimento texto.Ok, receita da minha vó não tinha parágrafos, metáfora não é perfeita, paciência.seguir, vamos descrever com mais calma esses conceitos de tokens, statements, blocks, e script.","code":""},{"path":"syntax-vars.html","id":"palavras","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.1.1 Palavras","text":"VocabulárioQuais palavras, tokens, temos disponíveis na linguagem R?Valores, que podem ser strings (palavras literais), números, valores booleanos (valores binários de verdadeiro ou falso), entre outros.\nTambém podemos ter “coleções” desses dados (ex: vários números em uma “lista”).\nTambém podemos ter “coleções” desses dados (ex: vários números em uma “lista”).Variáveis, nomes associados à objetos.\nfuturo, veremos que podemos associar muito mais que apenas dados à variáveis, por isso nomenclatura mais geral “objetos”.\nMais precisamente, “palava” em si é o nome.\nfuturo, veremos que podemos associar muito mais que apenas dados à variáveis, por isso nomenclatura mais geral “objetos”.Mais precisamente, “palava” em si é o nome.Funções, que definem operações à serem realizadas usando variáveis/valores.\nOperadores, símbolos como + e >, são um tipo de função especial, que apresentam uma sintaxe mais enxuta.\nOperadores, símbolos como + e >, são um tipo de função especial, que apresentam uma sintaxe mais enxuta.Em termos simplificados, dados e variáveis são nossos substantivos (variáveis são “nomes próprios”), enquanto funções são nossos verbos.Como escrevemos essas palavras em um texto em R?Strings: utilize aspas duplas \" ou aspas simples': \"Hello World!\", 'Hello World!'1.Números: simplesmente escreva-os: 1. Use um ponto . como o separador decimal 0.01.Valores booleanos: escreva palavras especiais TRUE e FALSE.Coleções: calma, tudo em seu tempo.Funções: escreva o nome da função, e os argumentos que ela receberá entre parênteses sum(1, 1). Não se preocupe muito com elas por agora.\nOperadores: são imputados como 1 + 1.\nParênteses podem ser utilizados em operações matemáticas: (1+1)/2.\nOperadores: são imputados como 1 + 1.Parênteses podem ser utilizados em operações matemáticas: (1+1)/2.Comentários: texto que não será avaliado como código. Use o símbolo #, que torna tudo após dele, na mesma linha, um comentário.Variáveis: já falei pra ter calma…","code":""},{"path":"syntax-vars.html","id":"frases","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.1.2 Frases","text":"Como dito, frases R serão combinações de tokens. Qualquer combinação.cada linha código abaixo é uma frase:Algumas frases são apenas um valor (1), o nome de uma variável (), chamada de uma função sum(1, 1){r}, ou combinação dessas coisas. Na seção seguinte irei apresentar um resultado sobre isso.E quanto um código como 1 +? Bom, esse código não é sintaticamente correto. Isso que estamos chamando de “frase”, quando sintaticamente correto, recebe o termo statement (declaração). partir de agora, vou parar de usar “frase”, e usar o termo mais formal, declaração.","code":"\n1\n1 + 1\na <- 1 #define a variável \"a\" com valor \"1\"\na #pede o valor da variável \"a\"\nsum(1, 1)\nsum(1, 1) + a"},{"path":"syntax-vars.html","id":"parágrafos","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.1.3 Parágrafos","text":"Como delimitamos declaração em parágrafos?Por padrão, uma declaração acaba na quebra de linha.Se declaração terminar inacabada (como exemplo 1 +), o R ignora quebra de linha, e tenta completar declaração com linha seguinte.Um ponto e vírgula pode ser usado para delimitar uma declarações explicitamente: 1 + 1; 2 + 2. Mas seu uso não é uma comum nem recomendável.Várias declarações podem ser agregadas em grupos ou blocks usando chaves {}. Um grupo de declarações é avaliado apenas após seu fim.veja alguns exemplos de declarações. note que frases podem ser compostas de outras declarações:partir de aqui, “declaração” ou “statement” se refere uma unidade ou um grupo de declarações.Nada disso deve fazer muito sentido em termos práticos ainda, tudo bem, apenas é preciso já ir se acostumando com estrutura geral de um programa.Antes de avançar, vou mentir um pouco e dar duas definições, mas que serão melhor detalhadas futuro.ExpressãoÉ uma declaração não avaliada, “congelada”, que o R não rodou.FunçãoÉ uma expressão, que depende de variáveis, associada à um nome. Utilizar esse nome, indicando os valores das variáveis envolvidas (entre parênteses ()), avalia declaração, retornando seu resultado.Com essa definição em mente, vale incluir funções na nossa analogia de parágrafos, uma vez que também usamos para organizar o texto.capítulo 6, veremos que operadores são funções como qualquer outra, que apenas apresentam uma sintaxe diferente.","code":"\na #é uma declaração\n1 #é uma declaração\n{1} #é a mesma declaração que a anterior\n\n1 + 1 #é uma declaração, uma operação \"+\" sobre dois \"1\"'s\n\n{\n  1 + 1\n  2 + 2\n} #é um bloco de declarações\n1 + 1; 2 + 2 #é a mesma declaração que a anterior\nliar <- {x + y} #meramente ilustrativo, a sintaxe real é mais complexa\nliar(x = 1, y = 2) #> 3\nliar(1, 2) #equivalente à declaração anterior"},{"path":"syntax-vars.html","id":"variáveis","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.2 Variáveis","text":"Um dos tipos de palavras, variáveis, merecem mais da nossa atenção. Mas não é para elas se acharem demais, dados e funções terão seus próprios capítulos.","code":""},{"path":"syntax-vars.html","id":"definindo-variáveis","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.2.1 Definindo Variáveis","text":"Para definir variáveis, escrevemos seu nome, = ou <-, e declaração que definirá seu valor: x = 1 + 1, x <- 1 + 1.Também podemos usar função assign(): assign(\"x\", 1).Variáveis, nomes, e objetosAo rodar algo como x <- 1, o valor 1 é salvo na memória computador, e associado ao nome x. Note que temos três parcelas:informação salva na memória computador (exemplo, 1), é chamada de objeto.O nome associado à esse objeto (exemplo, x), é chamado de, bom, nome.Variável se refere ao conjunto nome-objeto.capítulo 3, veremos que “tudo que existe R é um objeto”, isto é, esse conceito é muito abrangente.Por exemplo, na seção anterior, falei sobre unidades que compõe declarações. Elas também são objetos.Objetos da linguagemExistem três tipos de objetos que compõe linguagem R:names, nomes de variáveis.calls, chamadas de funções.expressions declarações não avaliadas. Note que expressões podem ser compostas de names e calls.Pense que valores, “objetos sem nome”, são efêmeros, por isso que não entram na lista acima.futuro, ficará claro que termos tão poucos objetos compondo linguagem é algo distintivo R, e gerará resultados que, eu pelo menos, considero muito bonitos (e gosto não se discute).","code":""},{"path":"syntax-vars.html","id":"copy-on-modify","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.2.2 Copy on Modify","text":"Com base que aprendeu, como pensaríamos em y <- x? resposta não é nada óbvia. Note que temos duas opções:y pode ser um novo nome, associado ao mesmo objeto, mesma posição na memória computador, que x.y pode ser um novo nome, associado um novo objeto, nova posição na memória computador, que x, mas carregando mesma informação.R, realidade é primeira opção. Porém, se y alterado, x não é (e vice versa). O que ocorre é que uma nova posição na memória é criada para armazenar (ao menos parte da) informação novo y. Esse processo, de apenas “separar”/“copiar” objetos quando modificados, é chamado de copy--modify.Diferentes tipos de dados terão diferentes relações com esse processo, mas vou poupá-los disso. O importante é saber que não temos os objetos são copiados quando modificados, alterar y não altera x e vice versa, independente da complexidade objeto.Em outras palavras:Copy--modifyNo R, um mesmo objeto pode ter ser referenciado mais de um nome. Modificar algum deles não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças.Existem duas exceções: objetos com apenas uma referência, e ambientes2. Esses são alterados “na hora”/“lugar”, ou modify--place.este tema é complexo, e foi bastante simplificado. Vide (Hadley Wickham 2019), seções “2.3 - Copy--modify” e “2.5 - Modify--place”. Os exemplos utilizando função tracemem() são especialmente úteis.","code":""},{"path":"syntax-vars.html","id":"outras-características","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.2.3 Outras Características","text":"Note que = e <- são muito similares, mas = serve para mais coisas que somente definição de variáveis, como indicar argumentos em uma função. Portanto, <- funciona como “definidor” em mais contextos, e é uma má prática utilizar = como definidor.Ambos podem definir várias variáveis de uma vez: x = y = 3, x <- y <- 3, x = y <- 3.Existe um terceiro operador <<-, que será discutido capítulo 6.","code":""},{"path":"syntax-vars.html","id":"regras-de-nomenclatura","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.2.4 Regras de Nomenclatura","text":"Nem toda combinação de caracteres pode ser um nome de variável. principais regras são:Nomes podem conter letras, números, “.” e “_“.São “case-sensitive”.Podem começar apenas com letras ou “.”.Não podem ser palavras reservadas como “TRUE”.Nomes não sintáticos podem ser definidos, se escritos usando crases (backticks) “`”: `_x` <- 1. Você provavelmente encontrará isso ao importar dados que não foram criados R.Em muitos momentos, o R converte nomes não sintáticos utilizando função make.names(). Você aprenderá sobre ela nos exercícios. É muito importante estar atento à esse comportamento, uma vez que é causa comum de erros.Você verá que isso é um tema comum: o R tenta facilitar muitas tarefas, fazendo coisas por você. Isso por um lado é o que o torna fácil de sair trabalhando, mas sempre é causa de inconsistências.","code":""},{"path":"syntax-vars.html","id":"operadores","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"2.3 Operadores","text":"princípio, deixaria os detalhes sobre operadores para os exercícios, mas fiquei com medo deles se sentirem excluídos.Abaixo estão os operadores relevantes para o momento, suas descrições, e seu uso. Clique nos links dos operadores para abrir suas páginas de ajuda.na coluna de “Uso”, “logi” se refere qualquer valor que se comporte como um valor booleano, “num” qualquer valor que se comporte como número, “expr” à qualquer expressão, e “x”/“y” à valores mais genéricos, ou à nomes de variáveis.Agora vou apresentar ordem de precedência da aplicação dos operadores. Associatividade se refere à como são resolvidos “empates”, “direita pra esquerda” significa que o operador mais à direita é analisado antes. Tudo ficará mais claro exemplo seguinte.linhas com um “(*)” apresentam operadores que ainda não foram apresentados.para deixar mais claro, na declaração (3+6)/(1+2)/5^4 o seguinte ocorre:() são analisados primeiro, porque tem precedência (estão acima na tabela).\nComo é da direita pra esquerda, primeiro (1+2) vira 3, e depois, (3+6) vira 9.\nComo é da direita pra esquerda, primeiro (1+2) vira 3, e depois, (3+6) vira 9.^ é analisado seguir, logo, 5^4 vira 625./ é analisado seguir.\nComo é da esquerda pra direita, primeiro 9/3 vira 3, e depois 3/625 vira 0.0048.\nComo é da esquerda pra direita, primeiro 9/3 vira 3, e depois 3/625 vira 0.0048.Vide (Stephanie Locke 2017b), capítulo “6 - Basic Operations” para mais detalhes e exemplos. Cuidado, alguns conceitos utilizados lá não foram vistos ainda.","code":""},{"path":"syntax-vars.html","id":"complemento","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Complemento","text":"","code":""},{"path":"syntax-vars.html","id":"recapitulando","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Recapitulando","text":"","code":""},{"path":"syntax-vars.html","id":"sintaxe-1","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Sintaxe","text":"Neste capítulo, vimos estrutura geral de um programa:palavras programa, podem ser valores, variáveis, ou funções.\nValores serão o tema próximo capítulo, e funções, capítulo @(functions-environments).\nVimos como imputar cada tipo de palavra.\nValores serão o tema próximo capítulo, e funções, capítulo @(functions-environments).Vimos como imputar cada tipo de palavra.frases (declarações) programa são combinações de palavras.\nCostumam ser delimitadas por quebras de linha.\nPodem ser organizadas em parágrafos vias chaves, ou “nomeadas” via funções.\nCostumam ser delimitadas por quebras de linha.Podem ser organizadas em parágrafos vias chaves, ou “nomeadas” via funções.Scripts, os programas escritos R, são sequências de frases.Vimos definições inciais para dois conceitos importantes:Uma expressão é uma declaração ainda não avaliada.Uma função é uma expressão, que depende de variáveis, associada à um nome.","code":""},{"path":"syntax-vars.html","id":"variáveis-1","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Variáveis","text":"Também demos uma atenção extra ao conceito de variável, nome, e objeto:Variáveis são nomes associados à informações na memória computador, os objetos.Aprendemos os operadores que definem variáveis = e <-, e porque <- é preferível.Vimos características como x <- y <- 3 e regras de nomenclatura.Bem como alguns conceitos mais técnicos e avançados:dinâmica da memória R é pautada pelo conceito de copy--modify. R, um mesmo objeto pode ter ser referenciado mais de um nome. Modificar algum deles não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças.\nexceções são objetos com apenas uma referência, e ambientes, que usam modify--place (são modificados “lugar”).\nexceções são objetos com apenas uma referência, e ambientes, que usam modify--place (são modificados “lugar”).O conceito de objeto é muito geral. Inclusive, própria linguagem R é composta por (apenas) três tipos de objetos: names, calls, e expressions. Expressões são algo mais geral, podendo ser compostas de names e calls.","code":""},{"path":"syntax-vars.html","id":"operadores-1","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Operadores","text":"Por fim, apresentamos os operadores básicos, seu uso, e ordem de preferência. Foi dito que operadores são funções, apenas com sintaxe diferente.","code":""},{"path":"syntax-vars.html","id":"exercícios","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Exercícios","text":"os exercícios usam variáveis de mesmo nome. Lembre-se de limpar definições de variáveis após completar um exercício, rodando frase rm(list = ls()).","code":""},{"path":"syntax-vars.html","id":"variáveis-2","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Variáveis","text":"Explique diferença entre 1 e cada uma das variáveis abaixo.Foi comentado que objetos mais complexos têm comportamentos diferentes com relação ao processo de definição , mas todos seguem uma característica geral. Com base nisso, o que você espera que ocorra com b após terceira linha código abaixo?você verá função list() próximo capítulo, mas saiba que ela cria uma lista, uma coleção, dos elementos que são passados como argumentos.Leia página de ajuda da função make.names() para aprender regras completas de definição de nomes, sobre como o R converte nomes não sintáticos. Preveja qual será o resultado das chamadas abaixo.","code":"\n1\na <- 1\nb <- a\nc <- a + 1\nd <- b\ne <- 1\na <- 1\nb <- list(a, a)\na <- a + 1\nmake.names(\"\")\nmake.names(\"@\")\nmake.names(\"TRUE\")\nmake.names(\"`TRUE`\")"},{"path":"syntax-vars.html","id":"operadores-2","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Operadores","text":"Parta de um número qualquer x, por exemplo, x <- 5. Use os ensinados operadores para criar:Uma frase que retorne TRUE se x múltiplo de 2.Uma frase que retorne TRUE se x não múltiplo nem de 3, nem de 5.Uma frase que retorne TRUE se parte inteira da divisão de x por 4 é igual 2, ou se seu quadrado maior ou igual à 10.Liste ordem das ações executadas cálculo da expressão abaixo:","code":"\nx <- FALSE | !5.2 %% 2*7*4 - -3 <= 100 & TRUE"},{"path":"syntax-vars.html","id":"dicionário-de-funções","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Dicionário de Funções","text":"Abaixo segue lista de funções vistas neste capítulo.","code":""},{"path":"syntax-vars.html","id":"referências","chapter":"Capítulo 2 Sintaxe e Variáveis","heading":"Referências","text":"referências principais deste capítulo são:(Hadley Wickham 2019) capítulo “2 - Names Values”, excluindo seções 2.4 e 2.6.(R Core Team 2024e) seções “2.1.3 - Language Objects” e “2.1.3 - Expression Objects”.(R Core Team 2024a) seções “2.1 - Vectors Assignment” e “2.2 - Vector Arithmetic”.(R Core Team 2024d) seção “2.1 - SEXPs”.(R Core Team 2024f) os documentos de ajuda das funções aqui expostas.Vide (Hadley Wickham 2019) seções “2.4 - Object Size” e “2.6 - Unbinding Garbage Collector”.","code":""},{"path":"data-attrs.html","id":"data-attrs","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"Capítulo 3 Tipos de Dados e Atributos","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"data-attrs.html","id":"famílias","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.1 Famílias","text":"","code":""},{"path":"data-attrs.html","id":"tipos-de-dados","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.1.1 Tipos de Dados","text":"R, os tipos de dados são organizados em “famílias”. Antes de entrar nesse mérito, abaixo estão os tipos mais importantes:Logical são os dados booleanos, podem ser TRUE ou FALSE. Podem ser abreviados para T e FCharacters são os dados de texto (strings)Integers são números inteiros, e são escritos com um L fimDoubles são os números decimais, podem ser decimais 1.245, científicos 1.23e4, ou hexadecimais 0xadfe\nValores especiais: Inf, -Inf, e NaN (“number”, usado em indefinições matemáticas)\nValores especiais: Inf, -Inf, e NaN (“number”, usado em indefinições matemáticas)Existem outros dois tipos menos utilizados: raw são os dados binários; complex são os números complexosTodos os tipos explicados assumem um valor especial, o “valor desconhecido”: NA (non aplicable)maioria das operações envolvendo NA`s retorna um NA: 1 + NA #> NAComo NA é um valor desconhecido, checar se um NA é igual ao outro não faz sentido NA == NA #> NAPor trás dos panos, existe um NA diferente para cada tipo de vetor atômico (NA_integer_, etc.)Um dado “sozinho” (3) é chamado de scalar. Mas o R também apresenta “coleções” de dados: (1, 2, 3, 4, 5)Uma coleção de escalares de um mesmo tipo é um atomic vectorUm escalar é uma “coleção de tamanho um”, e portanto, todo escalar é um vetor atômicoLogo, não existe um objeto “sem estar em um vetor”. x <- \"\" é um vetor atômico de tamanho 1Obs: os componentes de uma coleção são chamados de “elementos”Vetores atômicos não aceitam elementos de tipos diferentes, e não aceitam elementos que tamanho maior que umPorém, o R permite coleções com essas características, como (1, \"\", (1, 2, 3), TRUE, 1)Resumindo, temos:Os seis tipos “básicos” / tipos de escalaresVetores atômicos, coleções de escalares de mesmo tipo\nMesmo quando seu tamanho é unitário (os próprios escalares)\nMesmo quando seu tamanho é unitário (os próprios escalares)Vetores genéricos, coleções de vetores\nNão precisam ser atômicos, podem ter elementos de tipos diferentes\nNão precisam ser de escalares, podem ter elementos de tamanhos diferentes de 1\nConsequentemente, podem conter qualquer vetor, atômico ou genérico (si mesmos)\nApresentam seu próprio tipo, list\nNão precisam ser atômicos, podem ter elementos de tipos diferentesNão precisam ser de escalares, podem ter elementos de tamanhos diferentes de 1Consequentemente, podem conter qualquer vetor, atômico ou genérico (si mesmos)Apresentam seu próprio tipo, list","code":""},{"path":"data-attrs.html","id":"definição","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.1.1.1 Definição","text":"Uma coleção de vetores é um generic vector, ou, mais comumente, uma listUm vetor genérico/lista também é um vetor, de modo que listas podem conter outras listasA lista tem seu próprio tipo, list","code":""},{"path":"data-attrs.html","id":"famílias-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.1.2 Famílias","text":"Como disse, os tipos de dados R são organizados em “famílias”. Existem duas:Vector abrange os vetores atômicos e listas. É família dos dados “propriamente ditos”Node é família de “dados internos” R (funções, ambientes, etc.)Adicionalmente, NULL, um objeto especial, não é um vetor, mas pode ser entendido como “ausência de dado”/“vetor de tamanho zero”seguir, vamos entrar em detalhe sobre vetores","code":""},{"path":"data-attrs.html","id":"vetores-atômicos","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.2 Vetores atômicos","text":"Você já deveria saber que x <- 3 está criando um vetor atômico. Mas e para criar vetores atômicos mais longos?função c() combina (daí o nome) vetores em um mais longo. Ela serve com atômicos ou genéricos, mas por enquanto, vamos usá-la com atômicos:c(TRUE, FALSE)c(1L)c(1, 3.5, 1.23e4)c(\"\", \"2\")Quando usada com vetores atômicos, c() coage os inputs escalares mesmo tipo, resultando em um outro atomic vectorExample 3.1  Qual o resultado exemplo abaixo?\nE abaixo?\nExiste uma ordem de prioridade: se houver um character, tudo vira character, fora isso, tudo vira double, depois, integer, e por fim, logicalPodemos testar o tipo de um vetor com .logical(), .integer(), .double(), e .character()Existem funções extras .vector(), .atomic(), e .numeric(), mas são imprevisíveisPodemos transformar o tipo de um vetor com .logical(), .integer(), .double(), ou .character()mesmas contrapartes existem aquitypeof() retorna o tipo de um vetor, length() retorna seu tamanhoObs: funções que pedem argumentos de um mesmo tipo normalmente os coagem caso eles não o sejam","code":"\nc(c(1, 2), c(3, 4))\nc(1, 2, \"a\", \"b\")"},{"path":"data-attrs.html","id":"listas","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.3 Listas","text":"Características gerais:O typeof() de uma list é \"list\"Diferentemente dos V.., uma lista de tamanho 1 não é um escalarlist() cria uma nova listais.list() e .list()unlist() transforma uma lista em um vetor atômico, mas de maneiras inesperadasNo futuro, trataremos das funções pacote purrrNo tema de “Gerenciamento de memória” falaremos sobre como, por trás dos panos, listas são apenas referências aos objetos, de modo que list(x, x) ocupa bem menos que o dobro espaço de list(x)c() também pode combinar listasExample 3.2  Analise, desenhe, e compare os objetos abaixo:\nBasicamente, função list() cria “caixinhas” para cada um de seus argumentos, enquanto função c() não o faz","code":"\nl1 <- list(list(1), list(2))\nl2 <- list(list(1), 1)\nl3 <- list(list(1,2,3), c(1,2,3))\n\nl4 <- c(list(1), list(2))\nl5 <- c(list(1), 2)\nl6 <- c(list(1,2,3), c(1,2,3))"},{"path":"data-attrs.html","id":"atributos","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4 Atributos","text":"Os vetores podem carregar mais informações que apenas os valores de seus elementos, eles podem carregar metadados (dados que informam algo sobre os elementos), os atributosExistem três atributos principais:names, um vetor character, que nomeia cada elementodim (diminutivo de dimensions), um vetor integer, que reorganiza vetores em matrizes e arrays (“matrizes multidimensionais”)class, um vetor character, que indica um “tipo 2.0”, alterando o comportamento dos vetoresAtributos não afetam estrutura básica (tipo) dos objetos, mas podem afetar seu comportamento","code":""},{"path":"data-attrs.html","id":"nomes","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.1 Nomes","text":"Podemos nomear um vetor de várias formas:x <- c(= 1, b = 2, c = 3)names(x) <- c(\"\", \"b\", \"c\")x <- setNames(x, c(\"\", \"b\", \"c\")) (ou função set_names() pacote purrr)Podemos remover nomes com:x <- unname(x)Example 3.3  Que valor/objeto colocaríamos em y para remover os nomes?\nÉ fácil ver como estrutura básica fica inalterada. Tente transpor essa ideia para os outros atributos mais complexos","code":"\nnames(x) <- y"},{"path":"data-attrs.html","id":"dimensões","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.2 Dimensões","text":"Um vetor com o atributo dimensão é um vetor que deve ser interpretado como organizado em linhas e colunas (para matrizes):Ou como organizado em matrizes multidimensionais (para arrays):Também podemos ter matrizes e arrays feitas com listas:Example 3.4  Que lista complexa! Como poderíamos desenhá-la? E sua versão de matriz?Uma matriz ou array sempre é atômica?O que aconteceria com os outros elementos se eu alterasse o primeiro elemento de m1 para \"\"? E se eu fizesse o mesmo com m2?Como atributos não alteram estrutura básica, funções para vetores tem generalizações para matrizes e arrays:Note que adicionar dimensões gerou algumas possibilidadesUm tamanho e um atributo de nome para cada dimensãoManeiras diferentes de combinar objetosOperação de transposição (com t() e aperm())","code":"\nm1 <- c(T, F, T, T, F, T)\ndim(m1) <- c(2, 3)\n#ou matrix(c(T, F, T, T, F, T), nrow = 2, ncol = 3)\na1 <- c()\ndim(a1) <- c(2, 3, 2)\n#ou array(1:12, c(2, 3, 2))\nm2 <- list(1, 2, \"c\", list(\"d\"), TRUE, c(3, 4))\ndim(m2) <- c(2, 3)"},{"path":"data-attrs.html","id":"classes","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3 Classes","text":"Outro atributo importante é class, que permite criação de vetores diferenciados, criados em cima dos tipos básicosEsse atributo empodera o sistema de programação orientada ao objeto S3. Nele, funções agem diferentemente depender da classe argumento que estão recebendo. Abaixo vão algumas:factor são integers para dados categóricosDate, POSIXct, e difftime são doubles para datasdata.frame e tibble são lists para bases de dadosExistem outros como ts para séries de tempo, uma classe para cada tipo de vetor estudado, entre outrosObs: existem outras famílias de classes","code":""},{"path":"data-attrs.html","id":"factors","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.1 Factors","text":"Factors tem o atributo class como \"factor\", e um atributo levels que define os valores/categorias possíveisCuidado, factors comumente geram errosTambém existem os ordered factors, onde indicamos uma ordem para os levels, e costumam ser usados em funções de modelagem e visualização (vide ordered())","code":"\nfactor(c(\"m\", \"f\", \"f\", \"m\"),\n       levels = c(\"m\", \"f\", \"o\"))\n#> [1] m f f m\n#> Levels: m f o"},{"path":"data-attrs.html","id":"datas","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.2 Datas","text":"Dates: são um double com o atributo class \"Date\". Por trás dos panos são o número de dias desde 01/01/1970. Para criar: .Date(\"1970-02-01\")Date-times: são um double com o atributo class \"POSIXct\". Por trás dos panos são o número de segundos desde 01/01/1970. Para criar: .POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")Durations: são um double com o atributo class \"difftime\", que conta distância entre duas datas. Têm o atributo \"units\" que indica como o valor deve ser interpretado. Para criar: .difftime(1, units = \"weeks\")","code":""},{"path":"data-attrs.html","id":"data-frames","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.3 Data frames","text":"Um data frame é uma representação de uma tabela de dados. Basicamente, uma lista nomeada de vetores, normalmente atômicos, de mesmo tamanho:Como sempre, ter isso em mente ajudará muito transpor o conhecimento sobre listas para data framesData frames têm os atributos names (nomes das “colunas”), row.names (nomes das “linhas”), e class \"data.frame\"Funções úteis:São criados com data.frame()Um data frame tem nrow() linhasE ncol()/length() colunasTambém existem funções “” e “”Uma coluna de um data frame pode também ser uma matriz/array (se o número de linhas coincidir), ou uma lista (se o número de itens coincidir)Um Tibble é um sucessor data frame trazido pelo pacote “tibble” (parte tidyverse). Tibbles são “preguiçosos e grosseiros: fazem menos e reclamam mais”:Tem class c(\"data.frame\", \"tbl_df\")Não geram vetores maiores partir de vetores menores (data.frame(x = 1:4, y = 1:2))Não mudam nomes não sintáticosNão aceitam rownames (“metadata data”)Um subset de um tibble sempre é um tibbleNão tem matching parcial nos nomes de colunasPermitem referenciar colunas na hora da criação (tibble(x = 1:4, y = 2*x))Tem uma melhor visualização consoleAlgumas funções relacionadas à atributos:atributes(x) retorna uma lista com os atributos de xattr(x, \"attr\") retorna o valor atributo \"attr\"Atributos importantes têm funções próprias (names(), dim(), class())\nunclass(x) remove classe de x, retornando-o ao tipo base\nunclass(x) remove classe de x, retornando-o ao tipo basestructure(x, \"attr\" = valor) adiciona os atributos especificados em xstr(x) retorna uma visualização da estrutura de xObs: maior parte pode ser usada para definir/alterar valores de atributos","code":"\nlist(coluna1 = c(1, 2, 3),\n     coluna2 = c(\"c\", \"b\", \"d\"),\n     coluna3 = c(TRUE, FALSE, NA))"},{"path":"data-attrs.html","id":"complemento-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"Complemento","text":"","code":""},{"path":"data-attrs.html","id":"recapitulando-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"Recapitulando","text":"Como imputar valores“Definições” de expressão, função, e objeto (& nome)Criação de variáveis\nOperadores de definição = e <-\nRegras de nomenclatura\nOperadores de definição = e <-Regras de nomenclaturaDefinição. Metadados que alteram algo sobre o vetor\nnames alter visualização e como referenciar os elementos\ndim altera como o elemento é organizado, e é aplicável à todo tipo de vetor\nnames alter visualização e como referenciar os elementosdim altera como o elemento é organizado, e é aplicável à todo tipo de vetortypeof()/class() e funções “” e “” (extra: .na())Funções criadoras c(), list(), matrix(), array(), factor(), ordered(), data.frame(), tibble(), unlist()Funções combinadoras c(), cbind(), rbind(), e pacote “abind”Funções sobre dim: dim(), length(), nrow(), ncol()Funções sobre names: names, colnames(), rownames(), dimnames(), setNames()/set_names(), unname()Funções sobre atributes: str(), atributes(), attr(), structure(), unclass()Outras: t(), () (extra: stringsAsFactors = FALSE)","code":""},{"path":"data-attrs.html","id":"exercícios-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"Exercícios","text":"Example 3.5  Porque 1 == \"1\" é verdadeiro? Porque -1 < FALSE é verdadeiro? Porque \"one\" < 2 é falso?Agora com operações aritméticas. 1 + “2” funciona? e TRUE + 1? Qual é regra?Porque o NA padrão é um vetor lógico? Pense resultado de c(FALSE, NA_character_)Trabalhamos exemplos envolvendo c() e listas. Busque na página de ajuda ?c() pela ordem completa de coerçãoO que \"\" == c(\"\") retorna? e identical(\"\", c(\"\"))?Estude o argumento recursive = TRUE de c(). O que ele faria em: c(list(1), list(2)), c(list(1), 2), c(list(1,2,3), c(1,2,3))?Example 3.6  Estude os objetos abaixo. Desenhe-os:\nFaça o mesmo, agora estudando o tipo e classe:\nExample 3.7  Como setNames() funciona? Como unname() funciona? Olhe o código fonteO que dim() retorna quando aplicado um vetor unidimensional? Quando NROW() e NCOL() podem ser úteis?Como você descreveria os objetos abaixo? Qual diferença entre eles e 1:5?\nExample 3.8  O que faz função table()? Que objeto retorna? Qual seu tipo? Quais seus atributos? Como sua dimensão muda ao adicionar variáveis para tabular?O que acontece com um factor ao alterar seus níveis?\nO que o código abaixo faz? como f2 e f3 diferem de f1?\nExample 3.9  Pode haver um data frame com zero linhas? E zero colunas?O que ocorre se você definir rownames não únicos?Se df é um data frame, o que é t(df)? Porque? E t(t(df))?O que .matrix() faz quando aplicada um data frame com colunas de tipos diferentes? Como isso difere de usar data.matrix()?Example 3.10  Estude o objeto abaixo. colunas tem mesma length? Existe alguma outra medida de dimensão igual? Isso faz sentido?\n","code":"\nl1 <- list(1:3, \"a\", c(T, F, T), c(2.3, 5.9))\nl2 <- list(list(list(1)))\nl3 <- list(list(1, 2), c(3, 4))\nl4 <- c(list(1, 2), c(3, 4))\nl5 <- list(1:4, \"a\", list(\"a\"), matrix(1,2,3))\nl6 <- l5; dim(l6) <- c(2,2)\nl7 <- as.data.frame(l6)\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))\nf1 <- factor(letters)\nlevels(f1) <- rev(levels(f1))\nf2 <- rev(factor(letters))\nf3 <- factor(letters, levels = rev(letters))\nx <- data.frame(a = 1:2)\nx$b <- c(matrix(1, 1, 1), matrix(2, 1, 1))\nx$c <- list(matrix(1, 1, 1), matrix(2, 1, 1))\nx$d <- data.frame(c1 = factor(c(\"a\", \"b\")))"},{"path":"data-attrs.html","id":"vetores-atômicos-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.4 Vetores atômicos","text":"Porque 1 == \"1\" é verdadeiro? Porque -1 < FALSE é verdadeiro? Porque \"one\" < 2 é falso?Agora com operações aritméticas. 1 + “2” funciona? e TRUE + 1? Qual é regra?Porque o NA padrão é um vetor lógico? Pense resultado de c(FALSE, NA_character_)Trabalhamos exemplos envolvendo c() e listas. Busque na página de ajuda ?c() pela ordem completa de coerçãoO que \"\" == c(\"\") retorna? e identical(\"\", c(\"\"))?Estude o argumento recursive = TRUE de c(). O que ele faria em: c(list(1), list(2)), c(list(1), 2), c(list(1,2,3), c(1,2,3))?","code":""},{"path":"data-attrs.html","id":"listas-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.5 Listas","text":"Estude os objetos abaixo. Desenhe-os:\nFaça o mesmo, agora estudando o tipo e classe:\n","code":"\nl1 <- list(1:3, \"a\", c(T, F, T), c(2.3, 5.9))\nl2 <- list(list(list(1)))\nl3 <- list(list(1, 2), c(3, 4))\nl4 <- c(list(1, 2), c(3, 4))\nl5 <- list(1:4, \"a\", list(\"a\"), matrix(1,2,3))\nl6 <- l5; dim(l6) <- c(2,2)\nl7 <- as.data.frame(l6)"},{"path":"data-attrs.html","id":"atributos-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.6 Atributos","text":"Como setNames() funciona? Como unname() funciona? Olhe o código fonteO que dim() retorna quando aplicado um vetor unidimensional? Quando NROW() e NCOL() podem ser úteis?Como você descreveria os objetos abaixo? Qual diferença entre eles e 1:5?\n","code":"\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))"},{"path":"data-attrs.html","id":"vetores-atômicos-s3","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.7 Vetores atômicos S3","text":"O que faz função table()? Que objeto retorna? Qual seu tipo? Quais seus atributos? Como sua dimensão muda ao adicionar variáveis para tabular?O que acontece com um factor ao alterar seus níveis?\nO que o código abaixo faz? como f2 e f3 diferem de f1?\n","code":"\nf1 <- factor(letters)\nlevels(f1) <- rev(levels(f1))\nf2 <- rev(factor(letters))\nf3 <- factor(letters, levels = rev(letters))"},{"path":"data-attrs.html","id":"listas-s3","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.8 Listas S3","text":"Pode haver um data frame com zero linhas? E zero colunas?O que ocorre se você definir rownames não únicos?Se df é um data frame, o que é t(df)? Porque? E t(t(df))?O que .matrix() faz quando aplicada um data frame com colunas de tipos diferentes? Como isso difere de usar data.matrix()?","code":""},{"path":"data-attrs.html","id":"listas-s3-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"3.4.3.9 Listas S3","text":"Estude o objeto abaixo. colunas tem mesma length? Existe alguma outra medida de dimensão igual? Isso faz sentido?\n","code":"\nx <- data.frame(a = 1:2)\nx$b <- c(matrix(1, 1, 1), matrix(2, 1, 1))\nx$c <- list(matrix(1, 1, 1), matrix(2, 1, 1))\nx$d <- data.frame(c1 = factor(c(\"a\", \"b\")))"},{"path":"data-attrs.html","id":"dicionário-de-funções-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"Dicionário de Funções","text":"","code":""},{"path":"data-attrs.html","id":"referências-1","chapter":"Capítulo 3 Tipos de Dados e Atributos","heading":"Referências","text":"","code":""},{"path":"subset.html","id":"subset","chapter":"Capítulo 4 Subsetting","heading":"Capítulo 4 Subsetting","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"subset.html","id":"introdução-1","chapter":"Capítulo 4 Subsetting","heading":"4.1 Introdução","text":"Falamos sobre vetores, agora falaremos sobre como selecionar/alterar seus elementosExistem três operadores, [, [[. e $. Começaremos com [sintaxe geral é x[...], podemos usar várias técnicas diferentes lugar de “…”Para os exemplos:","code":"\nx <- c(1.3, 7.4, 6.0, 5.9)\nm <- matrix(1:9, nrow = 3, ncol = 3)\ncolnames(m) <- c(\"A\", \"B\", \"C\")\ndf <- as.data.frame(m)\nl <- list(\"a\" = 1:3, \"b\" = \"oi\", \"c\" = 4:6)"},{"path":"subset.html","id":"operador","chapter":"Capítulo 4 Subsetting","heading":"4.2 Operador [","text":"Existem seis maneiras:Inteiros positivos: retornam elementos nas posições\nx[1] #> 1.3\nx[1:3] #> 1.3 7.4 6.0\nx[c(1,3)] #> 1.3 6.0\nObs1: índices decimais são truncados: x[1.7] == x[1]\nObs2: factors são tratados como integers\nx[1] #> 1.3x[1:3] #> 1.3 7.4 6.0x[c(1,3)] #> 1.3 6.0Obs1: índices decimais são truncados: x[1.7] == x[1]Obs2: factors são tratados como integersInteiros negativos: retornam todos os elementos menos os das posições\nx[-c(1,3)] #> 7.4 5.9\nx[-c(1,3)] #> 7.4 5.9Vetores lógicos: retornam os elementos nas posições onde tem-se TRUE’s\nx[c(TRUE, TRUE, FALSE, FALSE)] #> 1.3 7.4\nO vetor lógico deve ser mesmo tamanho. O R tenta corrigir transgressões, mas regras de “reciclagem” são confusas (x[c(TRUE, FALSE)])\nx[c(TRUE, TRUE, FALSE, FALSE)] #> 1.3 7.4O vetor lógico deve ser mesmo tamanho. O R tenta corrigir transgressões, mas regras de “reciclagem” são confusas (x[c(TRUE, FALSE)])Vetores de texto: retornam os elementos com os nomes escolhidos\nc(= 1, b = 2, c = 3)[c(\"\", \"c\")] #> 1 3\nc(= 1, b = 2, c = 3)[c(\"\", \"c\")] #> 1 3Nada: x[] retorna o vetor originalZero: retorna um vetor de tamanho 0Obs: todos esses métodos podem reordenar os elementos x[c(1, 3, 2)]Com matrizes (vetores com dimensão), existem três maneiras:Múltiplos vetores: um vetor para cada dimensão\nm[c(TRUE, FALSE, TRUE), c(\"B\", \"\")]\nUm vetor omisso retorna todos os “elementos da dimensão”: [, c(1, 3)]\nPara arrays, use um argumento para cada dimensão [1:2, 2, , 4]\nm[c(TRUE, FALSE, TRUE), c(\"B\", \"\")]Um vetor omisso retorna todos os “elementos da dimensão”: [, c(1, 3)]Para arrays, use um argumento para cada dimensão [1:2, 2, , 4]Vetor único: como matrizes são vetores, podemos tratá-las como tal\nm[5:7] elemento 5 até o 7 (ordem é “column-major”)\nPodemos usar uma matriz lógica aqui, similar à usar um vetor lógico\nm[5:7] elemento 5 até o 7 (ordem é “column-major”)Podemos usar uma matriz lógica aqui, similar à usar um vetor lógicoMatrizes seletoras: onde cada coluna é uma dimensão, e cada linha um elemento quisto\nm[rbind(c(1,1), c(3,1), c(2,4))]\nPara arrays, precisamos de três ou mais colunas\nm[rbind(c(1,1), c(3,1), c(2,4))]Para arrays, precisamos de três ou mais colunasListas: mesmas maneiras que com vetores atômicos. [ sempre retorna uma lista, mesmo ao selecionar um único elementoExample 4.1  E para data frames? O que df[1:2] deve retornar? E df[1:2, ]? É “natural” que esses métodos coexistam?O operador [ simplifica dimensão resultadoEm matrizes/arrays, dimensões de length 1 são desfeitas\nm[1,], e m[,1]\nCom vetores únicos, todas são: m[1:9]\nm[1,], e m[,1]Com vetores únicos, todas são: m[1:9]Data frames “modo matriz” sofrem o mesmo, mas apenas para colunas\ndf[1,]\nMas df[,1] e df[1] mantêm dimensão\ndf[1,]Mas df[,1] e df[1] mantêm dimensãoIsso é controlado pelo argumento drop = TRUE operador. Podemos alterá-lo: df[1, , drop = FALSE]Tibbles tem drop = FALSE por padrão, sempre retornando outra tibble/nunca simplificando (alá preguiça)","code":""},{"path":"subset.html","id":"operador-e","chapter":"Capítulo 4 Subsetting","heading":"4.3 Operador [[ e $","text":"Para selecionar um único elemento, podemos usar os operadores [[ ou $Para pegar um elemento, e não uma lista, precisamos usar l[[\"\"]] lugar de l[\"\"]Example 4.2  Porque não existe essa diferenciação para vetores atômicos (x[1] == x[[1]])? Pode ser útil usar [[ mesmo assim?l$é uma abreviação de l[[\"\"]]. Diferença: $ faz “matching parcial” (da esquerda pra direita). Duvido vocês adivinharem se tibbles fazem isso ou nãoO operador [[ reage de maneiras estranhas quando se pede um elemento que não existe, vezes retorna erro, vezes NULL. Para lidar com isso, foram criadas funções:purrr::pluck() sempre retorna NULL (ou um valor definido pelo usuário)purrr::chuck() sempre retorna um erroObs: existem também @ e slot(), similares $ e [[ que servem para objetos S4 e não serão tratados aqui","code":""},{"path":"subset.html","id":"atribuição","chapter":"Capítulo 4 Subsetting","heading":"4.4 Atribuição","text":"Todos os operadores podem ser combinados com <-, numa operação chamada de sub-atribuiçãoO formato geral é x[] <- valor. Alguns comentários:Cheque se length(x[]) == length(valor). Pode gerar erros ou resultados inesperados via reciclagemPodemos re-assinalar mais de um elemento por vezCom listas, lembre que l[] sempre é uma lista\nl[] <- list(valor) é similar à l[[]] <- valor\nl[[]] <- NULL remove o item da lista, enquanto l[] <- list(NULL) altera o item para NULL\nl[] <- list(valor) é similar à l[[]] <- valorl[[]] <- NULL remove o item da lista, enquanto l[] <- list(NULL) altera o item para NULLPodemos “alterar o conteúdo de um objeto” (mantendo sua estrutura) lugar de “alterar o objeto em si”, usando o subset vazio\ndf[] <- .list(df) versus df <- .list(df)\ndf[] <- .list(df) versus df <- .list(df)","code":""},{"path":"subset.html","id":"aplicações","chapter":"Capítulo 4 Subsetting","heading":"4.5 Aplicações","text":"Example 4.3  Dado o vetor de abreviações abaixo, como criar o vetor extenso (“male” e “female”)\nResposta:\nExample 4.4  Agora, queremos fazer o match de um vetor de “tipos” com tabela que descreve cada tipo\nResposta:\nPara merges mais complexos, usaremos funções merge() e dplyr::left_join()Example 4.5  função sample(x, n) escolhe n elementos aleatórios vetor x. Como podemos utilizá-la para tirar uma amostra de um data frame?\nResposta:\nExample 4.6  É comum data frames terem uma coluna de “quantas vezes uma observação aparece”. função rep(x, y) repete cada entrada vetor x y[] vezes. Como podemos usá-la para expandir linhas?\nResposta:\nExample 4.7  Com índices, podemos usar - para fazer seleção negativa. Para nomes, use função () e/ou setdiff().\nResposta:\nExample 4.8  Como selecionar apenas linhas dataset mtcars cujo valor de “cyl” seja maior que 4?\nResposta:\n","code":"\nx <- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup <- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\ngrades <- c(1, 2, 2, 3, 1)\n\ninfo <- data.frame(grade = 3:1,\n                   desc = c(\"Good\", \"Med.\", \"Poor\"),\n                   fail = c(F, F, T))\ninfo[match(grades, info$grade), ]\ndf <- data.frame(x = c(1, 2, 3, 1, 2),\n                 y = 5:1,\n                 z = letters[1:5])\ndf[sample(nrow(df)), ]\ndf[sample(nrow(df), 3, replace = TRUE), ]\ndf <- data.frame(x = c(2, 4, 1),\n                 y = c(9, 11, 6),\n                 n = c(3, 5, 1))\ndf[rep(1:nrow(df), df$n), ]df[setdiff(names(df), \"n\")]\ndf[which(names(df) !%in% c(\"a\", \"b\"))]\nmtcars[mtcars$cyl > 4, ]\nmtcars[mtcars$cyl > 4 & mtcars$gear == 5, ]"},{"path":"subset.html","id":"lookup-vectors","chapter":"Capítulo 4 Subsetting","heading":"4.5.0.1 Lookup vectors","text":"Dado o vetor de abreviações abaixo, como criar o vetor extenso (“male” e “female”)\nResposta:\n","code":"\nx <- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup <- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]"},{"path":"subset.html","id":"lookup-tables","chapter":"Capítulo 4 Subsetting","heading":"4.5.0.2 Lookup tables","text":"Agora, queremos fazer o match de um vetor de “tipos” com tabela que descreve cada tipo\nResposta:\nPara merges mais complexos, usaremos funções merge() e dplyr::left_join()","code":"\ngrades <- c(1, 2, 2, 3, 1)\n\ninfo <- data.frame(grade = 3:1,\n                   desc = c(\"Good\", \"Med.\", \"Poor\"),\n                   fail = c(F, F, T))\ninfo[match(grades, info$grade), ]"},{"path":"subset.html","id":"amostragem-aleatória","chapter":"Capítulo 4 Subsetting","heading":"4.5.0.3 Amostragem aleatória","text":"função sample(x, n) escolhe n elementos aleatórios vetor x. Como podemos utilizá-la para tirar uma amostra de um data frame?\nResposta:\n","code":"\ndf <- data.frame(x = c(1, 2, 3, 1, 2),\n                 y = 5:1,\n                 z = letters[1:5])\ndf[sample(nrow(df)), ]\ndf[sample(nrow(df), 3, replace = TRUE), ]"},{"path":"subset.html","id":"expandindo-linhas-idênticas","chapter":"Capítulo 4 Subsetting","heading":"4.5.0.4 Expandindo linhas idênticas","text":"É comum data frames terem uma coluna de “quantas vezes uma observação aparece”. função rep(x, y) repete cada entrada vetor x y[] vezes. Como podemos usá-la para expandir linhas?\nResposta:\n","code":"\ndf <- data.frame(x = c(2, 4, 1),\n                 y = c(9, 11, 6),\n                 n = c(3, 5, 1))\ndf[rep(1:nrow(df), df$n), ]"},{"path":"subset.html","id":"seleção-negativa-com-characters","chapter":"Capítulo 4 Subsetting","heading":"4.5.0.5 Seleção negativa com characters","text":"Com índices, podemos usar - para fazer seleção negativa. Para nomes, use função () e/ou setdiff().\nResposta:\n","code":"df[setdiff(names(df), \"n\")]\ndf[which(names(df) !%in% c(\"a\", \"b\"))]"},{"path":"subset.html","id":"filtragem-de-datasets-com-condições","chapter":"Capítulo 4 Subsetting","heading":"4.5.0.6 Filtragem de datasets com condições","text":"Como selecionar apenas linhas dataset mtcars cujo valor de “cyl” seja maior que 4?\nResposta:\n","code":"\nmtcars[mtcars$cyl > 4, ]\nmtcars[mtcars$cyl > 4 & mtcars$gear == 5, ]"},{"path":"subset.html","id":"complemento-2","chapter":"Capítulo 4 Subsetting","heading":"Complemento","text":"","code":""},{"path":"subset.html","id":"recapitulando-2","chapter":"Capítulo 4 Subsetting","heading":"Recapitulando","text":"Vimos que existem seis maneiras básicas de acessar elementos de um vetor com [:Inteiro positivo com índices dos elementos quistosInteiro negativo com índices dos elementos à ignorarVetor lógico com TRUE nos índices dos elementos quistosVetor de texto com os nomes dos elementos quistosNada, x[], retornando o vetor originalZero, retornando um vetor de tamanho 0Adicionalmente, aprendemos sobre o comportamento de simplificação de dimensões (drop = TRUE)Sabendo características dos tipos de dados (aula .1) é fácil saber aplicar tais métodos aos diferentes objetos:Com matrizes, podemos:\nTratá-las como vetores (ordem “column-major”)\nUsar vetores atômicos ou até matrizes de mesmo tamanho\n\nTratar cada dimensão como uma seleção independente\nUso especial método “Nada”\n\nUsar matrizes seletoras\nTratá-las como vetores (ordem “column-major”)\nUsar vetores atômicos ou até matrizes de mesmo tamanho\nUsar vetores atômicos ou até matrizes de mesmo tamanhoTratar cada dimensão como uma seleção independente\nUso especial método “Nada”\nUso especial método “Nada”Usar matrizes seletorasCom listas, podemos:\nUsar os mesmos métodos, retornando uma sub-lista\nUsar [[ e $ para selecionar elementos específicos\nUsar os mesmos métodos, retornando uma sub-listaUsar [[ e $ para selecionar elementos específicosCom data frames, podemos tratá-los como matrizes ou listas, usando todos os métodos acimaEstudamos também algumas aplicaçõesLookup vectorsLookup tablesResamplingOrdenaçãoExpansão de linhas agregadasLogical subsetting","code":""},{"path":"subset.html","id":"exercícios-2","chapter":"Capítulo 4 Subsetting","heading":"Exercícios","text":"","code":""},{"path":"subset.html","id":"dicionário-de-funções-2","chapter":"Capítulo 4 Subsetting","heading":"Dicionário de Funções","text":"","code":""},{"path":"subset.html","id":"referências-2","chapter":"Capítulo 4 Subsetting","heading":"Referências","text":"","code":""},{"path":"control-conds.html","id":"control-conds","chapter":"Capítulo 5 Control Flow e Condições","heading":"Capítulo 5 Control Flow e Condições","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"control-conds.html","id":"introdução-2","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.1 Introdução","text":"ferramentas de control flow são aquelas que alteram ordem de execução de um dado códigoNo R, temos dois grupos principais:Choices, com , else, switch(), e ifelse()Loops, com repeat, , e ","code":""},{"path":"control-conds.html","id":"choices","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.2 Choices","text":"","code":""},{"path":"control-conds.html","id":"if-else","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.2.1 If & else","text":"Podemos criar uma expressão que apenas é avaliada se uma certa condição verdade. Se não , podemos complementar com expressões auxiliares:Características gerais:Podemos escrever essas expressões em uma linha, sem “{”Podemos utilizá-las para assinalar valores: x <- (TRUE) 1 else 2\nSe não houver nenhum else, retorna um NULL\nSe não houver nenhum else, retorna um NULLExample 5.1  O que o código abaixo vai retornar? Obs: paste() une strings\nfunção ifelse() funciona para um vetor de condições, diferentemente de , que exigia um único valor booleanoPara cada elemento, ela checa condição, e avalia uma ou outra expressão, salvando os resultados em um vetorExample 5.2  O que o código abaixo vai retornar?\n","code":"\nx <- 60\nif (x > 90) {\n  \"A\"\n} else if (x > 80) {\n  \"B\"\n} else if (x > 50) {\n  \"C\"\n} else {\n  \"F\"\n}\nnum <- runif(1) #sorteia um número entre 0 e 1\npaste(\"o número escolhido foi\", num,\n      if (num > 0.5) \"e ele é maior que 0.5\")\nx <- 1:10\nifelse(x > 5, NA, x)"},{"path":"control-conds.html","id":"and-and-e-or-or","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.2.2 And and e or or","text":"Existem os operadores “” && e “” || que garantem sempre um único valor booleano (dão erros com vetores longos), além de serem “short circuit”:Por isso, use && e || em , e & e | em ifelse()","code":"\nc(FALSE, TRUE) && TRUE\n#> erro por usar vetor longo\n\nc(FALSE) && stop()\n#> FALSE pois para no `FALSE`\n\nc(FALSE) & stop() #gera erro,\n#> erro, pois não para no `FALSE`"},{"path":"control-conds.html","id":"switch","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.2.3 Switch","text":"Existe uma maneira mais simples de escrever uma expressão de “escolha de opções”, com função switch():","code":"\nif (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"`x` inválido\")\n}\nswitch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"`x` inválido\")\n)"},{"path":"control-conds.html","id":"loops","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.3 Loops","text":"","code":""},{"path":"control-conds.html","id":"loops-for","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.3.1 Loops For","text":"Loops são usados para iterar em elementos de um vetor:item é literalmente um objeto, cujo valor vai sendo atualizado cada iteração, e fica armazenado ambiente globalA keyword next pula para próxima iteração, e break termina o loopExample 5.3  Como será ordem loop abaixo?\nDicas gerais:Ao usar um loop para criar uma variável, crie o “contêiner” de antemão, pois é bem mais rápido:Prefira usar seq_along(x) lugar de 1:length(x)Cuidado que loops costuma remover atributos. Use seq_along() e acesse os itens você mesmo","code":"\nfor (item in vector) expr\nfor (i in 1:10) {\n  if (i < 3) next\n  print(i)\n  if (i >= 5) break\n}\nx <- NULL; for(i in 1:5) x <- c(x, i)\nx <- NULL; for(i in 1:5) x[[i]] <- i\nx <- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (i in x) print(i)"},{"path":"control-conds.html","id":"outros-loops","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.3.2 Outros loops","text":"Se você não tem um vetor de opções de antemão, não sabe sobre quais valores quer iterar, você pode:Usar um loop (condition) {...}, que repete uma ação enquanto uma condição valerOu, ainda mais flexível, repeat(...), que repete uma ação para sempre até encontrar um breakÉ uma boa prática usar opção menos flexível possível, para dar menos brechas para erros. Prefira usar o , ou apply e purrr::map (tratadas futuro)","code":""},{"path":"control-conds.html","id":"condições","chapter":"Capítulo 5 Control Flow e Condições","heading":"5.4 Condições","text":"Seção sobre condições.","code":""},{"path":"control-conds.html","id":"complemento-3","chapter":"Capítulo 5 Control Flow e Condições","heading":"Complemento","text":"","code":""},{"path":"control-conds.html","id":"recapitulando-3","chapter":"Capítulo 5 Control Flow e Condições","heading":"Recapitulando","text":"Por fim, estudamos ferramentas de control flow:Choices, com , else, switch(), e ifelse()Loops, com repeat, , e forAprendemos alguns conhecimentos específicos de , operadores com &&, e observações específicas loop forSubsetting: [, [[, $ (argumento drop)\npurrr::pluck() e purrr::chuck()\nAplicações com match(), sample(), setdiff(), ()\npurrr::pluck() e purrr::chuck()Aplicações com match(), sample(), setdiff(), ()Control flow:\nChoices: , else, ifelse() e switch()\nOperadores && e ||\n\nLoops: repeat, , e \nFunção seq_along()\n\nKeywords: next, break\nChoices: , else, ifelse() e switch()\nOperadores && e ||\nOperadores && e ||Loops: repeat, , e \nFunção seq_along()\nFunção seq_along()Keywords: next, break","code":""},{"path":"control-conds.html","id":"exercícios-3","chapter":"Capítulo 5 Control Flow e Condições","heading":"Exercícios","text":"","code":""},{"path":"control-conds.html","id":"dicionário-de-funções-3","chapter":"Capítulo 5 Control Flow e Condições","heading":"Dicionário de Funções","text":"","code":""},{"path":"control-conds.html","id":"referências-3","chapter":"Capítulo 5 Control Flow e Condições","heading":"Referências","text":"","code":""},{"path":"funs-envs.html","id":"funs-envs","chapter":"Capítulo 6 Funções e Ambientes","heading":"Capítulo 6 Funções e Ambientes","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"funs-envs.html","id":"fundamentos","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.1 Fundamentos","text":"","code":""},{"path":"funs-envs.html","id":"introdução-3","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.1.1 Introdução","text":"Funções R são expressões que salvamos como um objeto, para utilizá-las repetidas vezes, variando seus argumentosElas são criadas com seguinte sintaxe:Elas têm três componentes:Seus argumentos (x e y), acessados com formals(fun_name)Seu corpo (x + y), acessado com body(fun_name)Seu environment, um objeto que determina onde função deve procurar os valores das variáveis relevantesAs únicas exceções existem R base, e são escritas em C em vez de R, por performance. Elas são funções primitivas, e não tem os componentes: sum #> .Primitive(\"sum\")Como dito, funções são objetos, criadas da mesma forma que x <- 3. Esse é o conceito de funções first-classComo qualquer objeto:Elas tem um tipo. “closure”, ou para primitivas “builtin” e “special”Podem ser passadas como argumentos para outras funçõesPodem ser salvas em listasFunções anônimas: note que não precisamos atribuídas um nome à uma função. Muito comum ao passar funções à outrasCall’s alternativas: podemos passar os argumentos via uma lista com função .call():Recursividade: funções R podem chamar elas mesmas. Vide o exemplo abaixo:Argumentos padrão: podemos deixar um argumento pré-definido: function(x, y = 1) ...","code":"\nfun_name <- function(x, y) { x + y } #ou\nfun_name <- \\(x, y) { x + y }\nfun_name(1, 2) #> 3\nfuns <- list(half = function(x) x / 2,\n             double = function(x) x * 2)\nfuns$double(10) #> [1] 20\ndo.call(fun_name, list(x = 1, y = 2)) #> 3\nrecursive_factorial <- function(x) {\n  if (x == 0) return(1)\n  else return(x * recursive.factorial(x - 1)) }"},{"path":"funs-envs.html","id":"formatos-e-combinações","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.1.2 Formatos e combinações","text":"R, “Everything exists object. Everything happens function call” -John ChambersExample 6.1  Qual conceito visto hoje exemplifica primeira parte slogan acima?segunda parte slogan fica clara ao saber que operadores e keywords também são funções, apenas com outro formatoA mais comum é o formato prefix: fun(x, y, ...). Veremos que os outros três podem ser escritos assimInfix: função vai meio de seus argumentos, x + y\nModo prefix: `+`(x, y)\nPara definir use um nome que comece e termine com “%”: %&% <- \\(x, y) paste(x, y)\nModo prefix: `+`(x, y)Para definir use um nome que comece e termine com “%”: %&% <- \\(x, y) paste(x, y)Replacement: funções que alterem valores de um objeto: names(df) <- ...\nModo prefix: `names<-`(df, ...)\nComo definir\nModo prefix: `names<-`(df, ...)Como definirSpecial: funções muito importantes para o R, cada uma com uma forma própria, como [[, , \n``(x > 0, x, x * (-1))\n``(var, seq, action)\n`next`(), e `break`()\n``(x > 0, x, x * (-1))``(var, seq, action)`next`(), e `break`()Obs: use isso para achar documentação de funções ?`[`Existem três formas de combinar funções:Nesting: g(f(x)), f realiza sua operação em x, e o resultado vira argumento para g\nÉ enxuto para pequenas expressões, mas pode ficar confuso em expressões muito longas\nÉ enxuto para pequenas expressões, mas pode ficar confuso em expressões muito longasObjetos intermediários: y <- f(x); z <- g(y)\nBom quando os valores intermediários são importantes, mas desnecessário quando não são\nBom quando os valores intermediários são importantes, mas desnecessário quando não sãoPiping: os operadores |> e magrittr::`%>%` chamam “pipe” (cano). Eles transformam avaliação de “dentro para fora” em “da esquerda pra direita”: f(x) %>% g()\nFacilita leitura de expressões longas, mas só serve quando é apenas um objeto que irá “avançar” ao longo da função\nFacilita leitura de expressões longas, mas só serve quando é apenas um objeto que irá “avançar” ao longo da função","code":""},{"path":"funs-envs.html","id":"exemplo","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.1.2.1 Exemplo","text":"Qual conceito visto hoje exemplifica primeira parte slogan acima?","code":""},{"path":"funs-envs.html","id":"ambientes","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.2 Ambientes","text":"Um environment é como uma lista nomeada, que associa nomes de variáveis aos seus valores. São neles que funções buscarão os valores das variáveisAmbientes são objetos (como tudo que existe R), com tipo “environment”, onde:Todos os nomes devem ser únicosNão existe uma ordem nos elementosTodo ambiente tem um um “ambiente pai”São o único tipo de objeto que não é copied modifiedNo R, funções salvam o ambiente onde foram criadas como parte de si, “enclose environments”, são closuresPortanto, o lugar onde buscam variáveis não muda depender de onde foram chamadasFunções criam um ambiente próprio para serem executadas:Filho de onde foram criadasContém os argumentos, e os valores criados em seu corpoAs funções buscam valores nos ambientes, começando pelo próprio, e avançando para os ambientes-pai até encontrar variável procuradabase: é o ambiente da pacote base R, o pacote que carrega todos os outrosAmbientes para pacotes: na ordem de chamada, pelo R (pacotes built-), e depois pelo usuário (via library())Ambiente global: o ambiente diretamente interativoAmbiente temporário: execução de funções","code":""},{"path":"funs-envs.html","id":"scoping-e-evaluation","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3 Scoping e Evaluation","text":"","code":""},{"path":"funs-envs.html","id":"scoping","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3.1 Scoping","text":"Agora sim podemos falar sobre como uma função busca por valores, operação de scopingName masking: nomes/objetos definidos dentro de uma função, e seus argumentos, “mascaram” nomes definidos fora da função\nO R só buscará uma variável ambiente-pai, se não encontrá-la ambiente da função\nO R só buscará uma variável ambiente-pai, se não encontrá-la ambiente da função“Tudo que existe é um objeto”, logo regra acima também vale para busca de funções\nSe uma função e um objeto tem mesmo nome, R interpreta nome() como sendo função, e nome como o objeto\nSe uma função e um objeto tem mesmo nome, R interpreta nome() como sendo função, e nome como o objetoInício zero: um novo ambiente temporário é criado cada chamada\nNão armazenamos informação de chamadas passadas, cada chamada é independente (menos que explicitamente se defina o contrário)\nNão armazenamos informação de chamadas passadas, cada chamada é independente (menos que explicitamente se defina o contrário)Dynamic lookup: funções buscam os valores na hora da chamada, não quando são criadas\nO “onde” não muda (closures), mas o “quando” sim\nResultados podem diferir antes e depois de se alterar uma variável relevante ambiente global\nO “onde” não muda (closures), mas o “quando” simResultados podem diferir antes e depois de se alterar uma variável relevante ambiente globalExample 6.2  Qual será o resultado código abaixo?\nResposta:\nExample 6.3  Qual será o resultado código abaixo?\nResposta:\nExample 6.4  Qual será o resultado código abaixo?\nResposta:\nExample 6.5  Qual será o resultado código abaixo?\nResposta:\n","code":"\na <- 1; b <- 2; c <- 3\n\nf <- function(b) {\n  a <- 10\n  c(a, b, c)\n}\n\nf(b = 20)\n#> [1] 10 20  3\nf <- function(x) x + 1\n\ng <- function() {\n  f <- function(x) x + 100\n  f(10)\n}\n\ng()\n#> [1] 110\nx <- 1\nf <- function() x <- x + 1; x\n\nf()\nf()\nx\n#> [1] 2\n#> [1] 2\n#> [1] 1\nf <- function() x + 1\n\nx <- 1\nf()\n\nx <- 100\nf()\n#> [1] 2\n#> [1] 101"},{"path":"funs-envs.html","id":"definição-1","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3.1.1 Definição","text":"O método utilizado pelo R é o lexical scoping (parse-time) e segue quatro regras principais (abaixo)","code":""},{"path":"funs-envs.html","id":"name-masking","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3.1.2 Name masking","text":"Qual será o resultado código abaixo?\nResposta:\n","code":"\na <- 1; b <- 2; c <- 3\n\nf <- function(b) {\n  a <- 10\n  c(a, b, c)\n}\n\nf(b = 20)\n#> [1] 10 20  3"},{"path":"funs-envs.html","id":"name-masking-com-funções","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3.1.3 Name masking com funções","text":"Qual será o resultado código abaixo?\nResposta:\n","code":"\nf <- function(x) x + 1\n\ng <- function() {\n  f <- function(x) x + 100\n  f(10)\n}\n\ng()\n#> [1] 110"},{"path":"funs-envs.html","id":"início-do-zero","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3.1.4 Início do zero","text":"Qual será o resultado código abaixo?\nResposta:\n","code":"\nx <- 1\nf <- function() x <- x + 1; x\n\nf()\nf()\nx\n#> [1] 2\n#> [1] 2\n#> [1] 1"},{"path":"funs-envs.html","id":"dynamic-lookup","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3.1.5 Dynamic lookup","text":"Qual será o resultado código abaixo?\nResposta:\n","code":"\nf <- function() x + 1\n\nx <- 1\nf()\n\nx <- 100\nf()\n#> [1] 2\n#> [1] 101"},{"path":"funs-envs.html","id":"lazy-evaluation","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3.2 Lazy evaluation","text":"Falamos sobre como os valores dos argumentos são buscados na hora da chamada, mas podemos ser mais específicosIsso permite incluir argumentos padrão que dependam de outros argumentos:Além de incluir argumentos que possivelmente exigem muita computação, sem gerar custo quando não forem utilizados:","code":"\nf <- function(x = 1, y = x * 2, z = a + b) {\n  a <- 3; b <- 4\n  c(x, y, z)\n}\nmean_unif <- function(a, b, sim = FALSE,\n                      x = runif(1000, a, b)) {\n  if (sim) mean(x) else (a + b)/2\n}"},{"path":"funs-envs.html","id":"definição-2","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.3.2.1 Definição","text":"Os argumentos são lazily evaluated: só são avaliados quando “acessados”. Isso é feito via armazená-los em um tipo de dado chamado promessa, que tem três componentes:Uma expressão, que será calculada futuroO ambiente onde ela deve ser avaliadaUm valor, o resultado da expressão, que substitui promessa após ser calculado","code":""},{"path":"funs-envs.html","id":"conceitos-adicionais","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.4 Conceitos Adicionais","text":"","code":""},{"path":"funs-envs.html","id":"dot-dot-dot","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.4.1 Dot dot dot","text":"Funções podem ter o argumento especial ... pronunciado “dot-dot-dot”, mas muitas vezes chamado de “varargs” em outras linguagensEle é útil se você não sabe listar todos os argumentos que sua função pode vir receber:Em funções que recebem funções como argumento (como lapply())Em funções genéricas (passar argumentos para métodos)","code":"\nfunction(x, fun, ...) { fun(x, ...) }"},{"path":"funs-envs.html","id":"resultados","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.4.2 Resultados","text":"Todas funções retornam algo:return() é usado para definir o resultado explicitamente, e encerrar execução da função\nÚtil em conjunto com & else\nÚtil em conjunto com & elsecaso contrário, função retorna o valor de sua última linhainvisible() pode ser usado para retornar um valor sem imprimi-lo\n(<- 2) #> [1] 2\n(<- 2) #> [1] 2","code":""},{"path":"funs-envs.html","id":"exit-handlers","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.4.3 Exit Handlers","text":"Você pode incluir avisos de erros em suas funções:stop(\"Erro: x deve ser numérico\")stopifnot(.numeric(x))Podemos usar função .exit() para rodar uma expressão quando uma função finalizar, independente motivo","code":""},{"path":"funs-envs.html","id":"pacotes","chapter":"Capítulo 6 Funções e Ambientes","heading":"6.4.4 Pacotes","text":"Um package é um conjunto de funções com um tema/objetivo específico. Eles contém uma documentação explicativa e vezes datasets para exemplosO CRAN armazena pacotes que passam testes específicos, mas qualquer um pode criar e postar um pacote GitHub. Vide install.packages() e o pacote “devtools”Após instalar, para carregar funções pacote na lista de ambientes, use library(pkg_name)Para aprender como criar seu próprio pacote, vide este tutorial MIT e o livro R Packages, 2nd Edition, também de Hadley WickhamO R base conta com 7 pacotes built-:“base” (fundação R, que inicia todos os outros pacotes)“graphics” e “grDevices” (funções gráficas)“utils” (funções utilitárias)“methods” (funções para OOP)“datasets” (bases de dados para treino)“stats” (funções estatísticas)Aprender sobre algumas das funções built-mais comuns ficará de exercício","code":""},{"path":"funs-envs.html","id":"complemento-4","chapter":"Capítulo 6 Funções e Ambientes","heading":"Complemento","text":"","code":""},{"path":"funs-envs.html","id":"recapitulando-4","chapter":"Capítulo 6 Funções e Ambientes","heading":"Recapitulando","text":"Sintaxe (de criação)Componentes (argumentos, corpo, e ambiente)\nExceção: funções primitivas\nExceção: funções primitivasFunções R são first-class e closuresFormas: prefix, infix, replacement, e specialCombinação: nesting, objetos intermediários, e pipingOutros: funções anônimas, .call(), recursividade, e argumentos padrãoSão “listas nomeadas” onde funções buscarão pelas variáveisAlém de salvar o ambiente em que foram criadas, funções criam um ambiente filho para serem executadasBase \\(\\leftarrow\\) Pacotes \\(\\leftarrow\\) Global \\(\\leftarrow\\) Função (temporário)Name masking: nomes na função tem prioridade, inclusive funçõesInício zero: um novo ambiente vazio é criado cada chamadaDynamic lookup: os valores são buscados na hora da chamadaLazy evaluation: os argumentos só são avaliados quando acessadosPromessas (expressão, ambiente, e valor)OOP:Classes, objetos, e métodosS3, R6, e S4Polimorfismo e funções genéricasConceitos adicionais:Dot dot dotResultadosExit handlersPacotesCriação: function() e \\()Componentes: formals(), body(), e environment().call()Pipes: |> e %>%Resultados: return() e invisible()Exit handlers: stop(), stopifnot(), e .exit()OOP: UseMethod(). Extra: use sloop::s3_get_method() para obter código fonte de métodosPacotes: install.packages() e library(). Extra: vide require()","code":""},{"path":"funs-envs.html","id":"exercícios-4","chapter":"Capítulo 6 Funções e Ambientes","heading":"Exercícios","text":"","code":""},{"path":"funs-envs.html","id":"dicionário-de-funções-4","chapter":"Capítulo 6 Funções e Ambientes","heading":"Dicionário de Funções","text":"","code":""},{"path":"funs-envs.html","id":"referências-4","chapter":"Capítulo 6 Funções e Ambientes","heading":"Referências","text":"","code":""},{"path":"paradigms.html","id":"paradigms","chapter":"Capítulo 7 Paradigmas de Programação","heading":"Capítulo 7 Paradigmas de Programação","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"paradigms.html","id":"programação-funcional","chapter":"Capítulo 7 Paradigmas de Programação","heading":"7.1 Programação Funcional","text":"Apresentação das ideias gerais da programação funcional. O grosso da aplicação será deixada para segunda parte livro, durante explicação pacote purrr. referência base são os capítulos 9, 10, e 11, “Advanced R”.","code":""},{"path":"paradigms.html","id":"programação-orientada-ao-objeto","chapter":"Capítulo 7 Paradigmas de Programação","heading":"7.2 Programação Orientada ao Objeto","text":"OOP centra maneira de resolver problemas em objetos métodos para os manipularO R é uma linguagem funcional (orientada à funções), mas tem pacotes que incluem funcionalidades de OOP","code":""},{"path":"paradigms.html","id":"definição-3","chapter":"Capítulo 7 Paradigmas de Programação","heading":"7.2.0.1 Definição","text":"OOP R é bem diferente de em outras linguagens mas ideia básica é mesma:Cada objeto tem uma classe class (o atributo)Cada classe tem methods “funções” que se aplicam uma classe específicaClasses podem ser criadas com base em outras, herdando os métodos de sua “classe pai”","code":""},{"path":"paradigms.html","id":"sistemas-de-oop","chapter":"Capítulo 7 Paradigmas de Programação","heading":"7.2.1 Sistemas de OOP","text":"R, existem três sistemas principais:S3, o primeiro, usado R base. É bastante flexível mas pouco rigorosoR6, que estende característica modify--place dos ambientes para outros tipos de objetosS4, uma versão mais rigorosa S3, útil para grandes projetosNeste curso, vamos falar apenas sobre o sistema S3","code":""},{"path":"paradigms.html","id":"polimorfismo","chapter":"Capítulo 7 Paradigmas de Programação","heading":"7.2.2 Polimorfismo","text":"principal aplicação de OOP R é o uso de polimorfismo, funções assumirem diferentes formas dependendo da classe de seu (primeiro) argumento:Chamamos essas funções de funções genéricas/generics","code":"\nx <- sample(1:10, 20, TRUE)\n\nsummary(as.numeric(x))\n#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  \n#   1.00    3.75    6.50    6.10    9.00   10.00 \n\nsummary(as.factor(x))\n#   1  3  4  5  6  7  8  9 10 \n#   2  3  1  1  3  3  1  5  1 "},{"path":"paradigms.html","id":"funções-genéricas","chapter":"Capítulo 7 Paradigmas de Programação","heading":"7.2.3 Funções genéricas","text":"Funções genéricas são um intermediário. Elas observam classe argumento passado, descobrem qual é o método correto ser executado:Chamamos função (genérica) – fun_name(x)função usa procura o método correto com base na classe de x – UseMethod(\"fun_name\")\nO nome desse processo é method dispatch\nO nome desse processo é method dispatchÉ encontrado o método, uma “função filho” – fun_name.class_of_x(x)Todas funções genéricas tem um método default fun_name.default(), caso não exista um método para uma classe específicaIntuitivamente, é similar usar um else:diferença é flexibilidade. Qualquer um pode criar uma classe e adicionar um método à uma função genérica, sem precisar alterar o “código base” da função","code":"\nfun_name.factor <- function(x) ...\nfun_name.numeric <- function(x) ...\nfun_name.default <- function(x) ...\n\nfun_name <- function(x) {\n  if(is.factor(x)) { fun_name.factor(x)\n  } else if(is.numeric(x)) { fun_name.numeric(x)\n  } else { fun_name.default(x) }\n}"},{"path":"paradigms.html","id":"metaprogramação","chapter":"Capítulo 7 Paradigmas de Programação","heading":"7.3 Metaprogramação","text":"Apresentação das ideias gerais da metaprogramação. especialmente sobre bases tidyverse. referência base são os capítulos 17, 18, 19, e 20, “Advanced R”. Apresento o pacote “rlang”.","code":""},{"path":"paradigms.html","id":"complemento-5","chapter":"Capítulo 7 Paradigmas de Programação","heading":"Complemento","text":"","code":""},{"path":"paradigms.html","id":"recapitulando-5","chapter":"Capítulo 7 Paradigmas de Programação","heading":"Recapitulando","text":"","code":""},{"path":"paradigms.html","id":"exercícios-5","chapter":"Capítulo 7 Paradigmas de Programação","heading":"Exercícios","text":"","code":""},{"path":"paradigms.html","id":"dicionário-de-funções-5","chapter":"Capítulo 7 Paradigmas de Programação","heading":"Dicionário de Funções","text":"","code":""},{"path":"paradigms.html","id":"referências-5","chapter":"Capítulo 7 Paradigmas de Programação","heading":"Referências","text":"","code":""},{"path":"others1.html","id":"others1","chapter":"Capítulo 8 Outros Tópicos","heading":"Capítulo 8 Outros Tópicos","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"others1.html","id":"projetos-github-e-addins","chapter":"Capítulo 8 Outros Tópicos","heading":"8.1 Projetos, Github, e Addins","text":"Existem muitas ferramentas que facilitam vida programador. Aqui ensinarei sobre como organizar seus, bem, projetos, com os “Projetos” RStudio. Darei uma introdução ao controle de versão com Git e sua integração com o RStudio, uma ferramenta que mais programadores deveriam utilizar. E por fim, algumas extensões de “qualidade de vida” disponíveis para o RStudio.","code":""},{"path":"others1.html","id":"debbuging","chapter":"Capítulo 8 Outros Tópicos","heading":"8.2 Debbuging","text":"Um dos maiores benefícios da abordagem da primeira parte livro é entender melhor causas dos erros. Aqui, mostrarei como esse conhecimento pode ser aplicado, utilizando ferramentas de debugging RStudio.","code":""},{"path":"others1.html","id":"gerenciamento-de-memória-e-performance","chapter":"Capítulo 8 Outros Tópicos","heading":"8.3 Gerenciamento de Memória e Performance","text":"Um tema mais avançado, para aqueles que precisam fazer códigos eficientes, é como o R gerencia memória. Darei dicas objetivas para otimizar seu código.","code":""},{"path":"others1.html","id":"organização-de-código-e-boas-práticas","chapter":"Capítulo 8 Outros Tópicos","heading":"8.4 Organização de Código e Boas Práticas","text":"Escrever códigos de maneira limpa e estética é importante, para evitar erros e deixá-los entendíveis. Falarei sobre estilos de código, principalmente o estilo tidyverse, bem como alguns pacotes que ajudam o programador, lintr, e styler.","code":""},{"path":"others1.html","id":"complemento-6","chapter":"Capítulo 8 Outros Tópicos","heading":"Complemento","text":"","code":""},{"path":"others1.html","id":"recapitulando-6","chapter":"Capítulo 8 Outros Tópicos","heading":"Recapitulando","text":"","code":""},{"path":"others1.html","id":"exercícios-6","chapter":"Capítulo 8 Outros Tópicos","heading":"Exercícios","text":"","code":""},{"path":"others1.html","id":"dicionário-de-funções-6","chapter":"Capítulo 8 Outros Tópicos","heading":"Dicionário de Funções","text":"","code":""},{"path":"others1.html","id":"referências-6","chapter":"Capítulo 8 Outros Tópicos","heading":"Referências","text":"","code":""},{"path":"recap1.html","id":"recap1","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da primeira parte, falando dos principais aprendizados sobre como o R funciona, e também relembrando os conceitos aprendidos.","code":""},{"path":"recap1.html","id":"complemento-7","chapter":"Recapitulando","heading":"Complemento","text":"","code":""},{"path":"recap1.html","id":"recapitulando-7","chapter":"Recapitulando","heading":"Recapitulando","text":"","code":""},{"path":"recap1.html","id":"exercícios-7","chapter":"Recapitulando","heading":"Exercícios","text":"","code":""},{"path":"recap1.html","id":"dicionário-de-funções-7","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"recap1.html","id":"referências-7","chapter":"Recapitulando","heading":"Referências","text":"","code":""},{"path":"intro2.html","id":"intro2","chapter":"Parte II - Ciência de Dados com o Tidyverse","heading":"Parte II - Ciência de Dados com o Tidyverse","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Bem vindo à segunda parte deste livro. Aqui, foco em ensinar sobre duas das tarefas mais comuns em aplicações R, manipulação e visualização de dados. Porém, ensino esses conceitas com base na “teoria” por trás de projetos de ciência de dados.Começo explicando como funcionam projetos de ciência de dados, muito com base em (Hadley Wickham Garrett Grolemund 2024).seguir, apresento o tidyverse, que é um frameworks para manipulação e visualização de dados. Escolhi falar sobre ele, em oposição à usar o R base, ou outro framework, porque ele é um dos agregados de pacotes mais bem trabalhados, com uma sintaxe simples de entender, e que abrange todas etapas da manipulação de dados. Especialmente, os conceitos expostos na parte farão com que sua compreensão seja muito mais simples. Aqui, documentação oficial (“Tidyverse,” n.d.) também é muito usada.Nessa segunda parte, começo utilizar mais exemplos, uma vez que manipular dados é uma tarefa bastante aplicada. Ainda assim, não tantos quanto outros livros, e considerações gerais sobre o estilo presente material se mantêm.Os capítulos estão organizados por etapas de um projeto, e pacotes tidyverse:Capítulo 9: descrevo os fundamentos e etapas de um projeto de ciência de dados. Também adianto como importar diferentes tipos de arquivos para o R usando o pacote “readr”.Capítulo 10: descrevo os fundamentos e operações da manipulação de dados. Falo como aplicá-las usando os pacotes “dplyr” e “tidyr”.Capítulo 11: descrevo os fundamentos da visualização de dados. Falo como aplicá-la usando o pacote “ggplot2”.Capítulo 12: falo mais sobre strings e factors R. Apresento ferramentas de manipulação nos pacotes “stringr”, “forecats”, e “glue”.Capítulo 13: falo sobre aplicações da programação funcional com o pacote “purrr”.Capítulo 14: falo sobre manipulação de datas e séries de tempo com o pacote “lubridate”, e (pacote definir).Recapitulado: seção para retomar os conteúdos aprendidos.","code":""},{"path":"ds-import.html","id":"ds-import","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"Capítulo 9 Ciência de Dados e Importação","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, descreverei os fundamentos e etapas de um projeto de ciência de dados. Também adianto como importar diferentes tipos de arquivos para o R usando o pacote “readr”.","code":""},{"path":"ds-import.html","id":"ciência-de-dados","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"9.1 Ciência de Dados","text":"","code":""},{"path":"ds-import.html","id":"introdução-4","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"9.1.1 Introdução","text":"Ciência de Dados: “aplicação de métodos estatísticos e computacionais para análise de dados”.Um projeto de ciência de dados normalmente segue o seguinte fluxo:","code":""},{"path":"ds-import.html","id":"preparar","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"9.1.2 Preparar","text":"Importar os dados: o passo inicial de qualquer projeto de ciência de dados. É necessário saber o tipo de arquivo, o tipo da fonte (arquivos, databases, API’s), e ferramentas de importação disponíveis.Importar os dados: o passo inicial de qualquer projeto de ciência de dados. É necessário saber o tipo de arquivo, o tipo da fonte (arquivos, databases, API’s), e ferramentas de importação disponíveis.Arrumar (tidy) os dados: limpar e organizar os dados de acordo com o formato necessário. Em D.S., muitas vezes queremos o formato “tidy”, onde cada coluna representa uma variável e cada linha uma observação.Arrumar (tidy) os dados: limpar e organizar os dados de acordo com o formato necessário. Em D.S., muitas vezes queremos o formato “tidy”, onde cada coluna representa uma variável e cada linha uma observação.Transformar os dados: refinar seus dados para facilitar uma visualização ou modelagem específica. Este passo envolve reduzir observações, criar novas variáveis e calcular estatísticas resumo.Transformar os dados: refinar seus dados para facilitar uma visualização ou modelagem específica. Este passo envolve reduzir observações, criar novas variáveis e calcular estatísticas resumo.Esses três passo juntos são referidos como data wrangling (“preparação” de dados).","code":""},{"path":"ds-import.html","id":"entender-e-explorar","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"9.1.3 Entender e Explorar","text":"Visualização: explorar os dados de maneiras mais interessantes visualmente. Boas visualizações podem revelar mais informação sobre o problema, levantar questões para se atentar, e demandas por mais dados e/ou outros modelos.Visualização: explorar os dados de maneiras mais interessantes visualmente. Boas visualizações podem revelar mais informação sobre o problema, levantar questões para se atentar, e demandas por mais dados e/ou outros modelos.Modelagem: modelos são ferramentas para responder perguntas sobre o processo gerador dos dados. Eles são conjuntos de hipóteses sobre o problema em mãos, acompanhados por um método computacional para sua estimação. Cada modelo tem seu conjunto de hipóteses, e seus métodos de estimação.Modelagem: modelos são ferramentas para responder perguntas sobre o processo gerador dos dados. Eles são conjuntos de hipóteses sobre o problema em mãos, acompanhados por um método computacional para sua estimação. Cada modelo tem seu conjunto de hipóteses, e seus métodos de estimação.Transformar os dados: após entender melhor demandas problema, é comum voltar ao passo de transformação dos dados, e repetir o ciclo, até que toda informação quista seja obtida.Transformar os dados: após entender melhor demandas problema, é comum voltar ao passo de transformação dos dados, e repetir o ciclo, até que toda informação quista seja obtida.","code":""},{"path":"ds-import.html","id":"communicating-and-executing","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"9.1.4 Communicating and Executing","text":"Comunicação: após o problema ser analisado, é preciso reportar os resultadosComunicação: após o problema ser analisado, é preciso reportar os resultadosCommunication: Communication integral data analysis project. involves conveying findings others effectively. matter insightful models visualizations , value limited communicate results clear understandable manner.Communication: Communication integral data analysis project. involves conveying findings others effectively. matter insightful models visualizations , value limited communicate results clear understandable manner.Programming: Programming pervasive tool data science. mandatory expert programmer, improving programming skills aids automating tasks tackling new challenges efficiently. Programming cross-cutting skill used throughout entire data science project.Programming: Programming pervasive tool data science. mandatory expert programmer, improving programming skills aids automating tasks tackling new challenges efficiently. Programming cross-cutting skill used throughout entire data science project.","code":""},{"path":"ds-import.html","id":"complemento-8","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"Complemento","text":"","code":""},{"path":"ds-import.html","id":"recapitulando-8","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"Recapitulando","text":"","code":""},{"path":"ds-import.html","id":"exercícios-8","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"Exercícios","text":"","code":""},{"path":"ds-import.html","id":"dicionário-de-funções-8","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"Dicionário de Funções","text":"","code":""},{"path":"ds-import.html","id":"referências-8","chapter":"Capítulo 9 Ciência de Dados e Importação","heading":"Referências","text":"","code":""},{"path":"manipulation.html","id":"manipulation","chapter":"Capítulo 10 Manipulação de Dados","heading":"Capítulo 10 Manipulação de Dados","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, descreverei os fundamentos e operações da manipulação de dados. Falo como aplicá-las usando os pacotes “dplyr” e “tidyr”.","code":""},{"path":"manipulation.html","id":"operações-de-manipulação","chapter":"Capítulo 10 Manipulação de Dados","heading":"10.1 Operações de Manipulação","text":"","code":""},{"path":"manipulation.html","id":"operações-em-observações","chapter":"Capítulo 10 Manipulação de Dados","heading":"10.1.1 Operações em Observações","text":"","code":""},{"path":"manipulation.html","id":"operações-em-variáveis","chapter":"Capítulo 10 Manipulação de Dados","heading":"10.1.2 Operações em Variáveis","text":"","code":""},{"path":"manipulation.html","id":"operações-em-células","chapter":"Capítulo 10 Manipulação de Dados","heading":"10.1.3 Operações em Células","text":"","code":""},{"path":"manipulation.html","id":"operações-em-grupos","chapter":"Capítulo 10 Manipulação de Dados","heading":"10.1.4 Operações em Grupos","text":"","code":""},{"path":"manipulation.html","id":"operações-de-união","chapter":"Capítulo 10 Manipulação de Dados","heading":"10.1.5 Operações de União","text":"","code":""},{"path":"manipulation.html","id":"operações-de-remodelação","chapter":"Capítulo 10 Manipulação de Dados","heading":"10.1.6 Operações de Remodelação","text":"","code":""},{"path":"manipulation.html","id":"complemento-9","chapter":"Capítulo 10 Manipulação de Dados","heading":"Complemento","text":"","code":""},{"path":"manipulation.html","id":"recapitulando-9","chapter":"Capítulo 10 Manipulação de Dados","heading":"Recapitulando","text":"","code":""},{"path":"manipulation.html","id":"exercícios-9","chapter":"Capítulo 10 Manipulação de Dados","heading":"Exercícios","text":"","code":""},{"path":"manipulation.html","id":"dicionário-de-funções-9","chapter":"Capítulo 10 Manipulação de Dados","heading":"Dicionário de Funções","text":"","code":""},{"path":"manipulation.html","id":"referências-9","chapter":"Capítulo 10 Manipulação de Dados","heading":"Referências","text":"","code":""},{"path":"visualization.html","id":"visualization","chapter":"Capítulo 11 Visualização Gráfica","heading":"Capítulo 11 Visualização Gráfica","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, descreverei os fundamentos da visualização de dados. Falo como aplicá-la usando o pacote “ggplot2”.","code":""},{"path":"visualization.html","id":"introdução-à-visualização","chapter":"Capítulo 11 Visualização Gráfica","heading":"11.1 Introdução à Visualização","text":"","code":""},{"path":"visualization.html","id":"layers","chapter":"Capítulo 11 Visualização Gráfica","heading":"11.2 Layers","text":"","code":""},{"path":"visualization.html","id":"scales","chapter":"Capítulo 11 Visualização Gráfica","heading":"11.3 Scales","text":"","code":""},{"path":"visualization.html","id":"grammar","chapter":"Capítulo 11 Visualização Gráfica","heading":"11.4 Grammar","text":"","code":""},{"path":"visualization.html","id":"others","chapter":"Capítulo 11 Visualização Gráfica","heading":"11.5 Others","text":"","code":""},{"path":"visualization.html","id":"complemento-10","chapter":"Capítulo 11 Visualização Gráfica","heading":"Complemento","text":"","code":""},{"path":"visualization.html","id":"recapitulando-10","chapter":"Capítulo 11 Visualização Gráfica","heading":"Recapitulando","text":"","code":""},{"path":"visualization.html","id":"exercícios-10","chapter":"Capítulo 11 Visualização Gráfica","heading":"Exercícios","text":"","code":""},{"path":"visualization.html","id":"dicionário-de-funções-10","chapter":"Capítulo 11 Visualização Gráfica","heading":"Dicionário de Funções","text":"","code":""},{"path":"visualization.html","id":"referências-10","chapter":"Capítulo 11 Visualização Gráfica","heading":"Referências","text":"","code":""},{"path":"strings-factors.html","id":"strings-factors","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"Capítulo 12 Manipulação de Strings e Factors","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, falarei mais sobre strings e factors R. Apresento ferramentas de manipulação nos pacotes “stringr”, “forecats”, e “glue”.","code":""},{"path":"strings-factors.html","id":"strings","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.1 Strings","text":"","code":""},{"path":"strings-factors.html","id":"matches","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.1.1 Matches","text":"","code":""},{"path":"strings-factors.html","id":"mutate","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.1.2 Mutate","text":"","code":""},{"path":"strings-factors.html","id":"subset-1","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.1.3 Subset","text":"","code":""},{"path":"strings-factors.html","id":"join-and-split","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.1.4 Join and Split","text":"","code":""},{"path":"strings-factors.html","id":"lengths","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.1.5 Lengths","text":"","code":""},{"path":"strings-factors.html","id":"order","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.1.6 Order","text":"","code":""},{"path":"strings-factors.html","id":"factors-1","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.2 Factors","text":"","code":""},{"path":"strings-factors.html","id":"inspect","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.2.1 Inspect","text":"","code":""},{"path":"strings-factors.html","id":"combine","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.2.2 Combine","text":"","code":""},{"path":"strings-factors.html","id":"reorder","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.2.3 Reorder","text":"","code":""},{"path":"strings-factors.html","id":"revalue","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.2.4 Revalue","text":"","code":""},{"path":"strings-factors.html","id":"relevel","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"12.2.5 Relevel","text":"","code":""},{"path":"strings-factors.html","id":"complemento-11","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"Complemento","text":"","code":""},{"path":"strings-factors.html","id":"recapitulando-11","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"Recapitulando","text":"","code":""},{"path":"strings-factors.html","id":"exercícios-11","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"Exercícios","text":"","code":""},{"path":"strings-factors.html","id":"dicionário-de-funções-11","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"Dicionário de Funções","text":"","code":""},{"path":"strings-factors.html","id":"referências-11","chapter":"Capítulo 12 Manipulação de Strings e Factors","heading":"Referências","text":"","code":""},{"path":"functional.html","id":"functional","chapter":"Capítulo 13 Programação Funcional","heading":"Capítulo 13 Programação Funcional","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, falarei sobre aplicações da programação funcional com o pacote “purrr”.","code":""},{"path":"functional.html","id":"map","chapter":"Capítulo 13 Programação Funcional","heading":"13.1 Map","text":"","code":""},{"path":"functional.html","id":"map-1","chapter":"Capítulo 13 Programação Funcional","heading":"13.1.1 Map 1","text":"","code":""},{"path":"functional.html","id":"map-2","chapter":"Capítulo 13 Programação Funcional","heading":"13.1.2 Map 2","text":"","code":""},{"path":"functional.html","id":"map-p","chapter":"Capítulo 13 Programação Funcional","heading":"13.1.3 Map p","text":"","code":""},{"path":"functional.html","id":"others-1","chapter":"Capítulo 13 Programação Funcional","heading":"13.2 Others","text":"","code":""},{"path":"functional.html","id":"modify","chapter":"Capítulo 13 Programação Funcional","heading":"13.2.1 Modify","text":"","code":""},{"path":"functional.html","id":"reduce","chapter":"Capítulo 13 Programação Funcional","heading":"13.2.2 Reduce","text":"","code":""},{"path":"functional.html","id":"predicates","chapter":"Capítulo 13 Programação Funcional","heading":"13.2.3 Predicates","text":"","code":""},{"path":"functional.html","id":"pluck","chapter":"Capítulo 13 Programação Funcional","heading":"13.2.4 Pluck","text":"","code":""},{"path":"functional.html","id":"reshape","chapter":"Capítulo 13 Programação Funcional","heading":"13.2.5 Reshape","text":"","code":""},{"path":"functional.html","id":"concatenate","chapter":"Capítulo 13 Programação Funcional","heading":"13.2.6 Concatenate","text":"","code":""},{"path":"functional.html","id":"complemento-12","chapter":"Capítulo 13 Programação Funcional","heading":"Complemento","text":"","code":""},{"path":"functional.html","id":"recapitulando-12","chapter":"Capítulo 13 Programação Funcional","heading":"Recapitulando","text":"","code":""},{"path":"functional.html","id":"exercícios-12","chapter":"Capítulo 13 Programação Funcional","heading":"Exercícios","text":"","code":""},{"path":"functional.html","id":"dicionário-de-funções-12","chapter":"Capítulo 13 Programação Funcional","heading":"Dicionário de Funções","text":"","code":""},{"path":"functional.html","id":"referências-12","chapter":"Capítulo 13 Programação Funcional","heading":"Referências","text":"","code":""},{"path":"time-series.html","id":"time-series","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"Capítulo 14 Manipulação de Datas e Séries de Tempo","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, falarei sobre manipulação de datas e séries de tempo com o pacote “lubridate”, e (pacote definir).","code":""},{"path":"time-series.html","id":"dates","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"14.1 Dates","text":"","code":""},{"path":"time-series.html","id":"parsing","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"14.1.1 Parsing","text":"","code":""},{"path":"time-series.html","id":"mutate-1","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"14.1.2 Mutate","text":"","code":""},{"path":"time-series.html","id":"time-zones","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"14.1.3 Time Zones","text":"","code":""},{"path":"time-series.html","id":"math","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"14.1.4 Math","text":"","code":""},{"path":"time-series.html","id":"periods-durations-e-intervals","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"14.1.5 Periods, Durations, e Intervals","text":"","code":""},{"path":"time-series.html","id":"time-series-1","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"14.2 Time Series","text":"Framework ser definido","code":""},{"path":"time-series.html","id":"complemento-13","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"Complemento","text":"","code":""},{"path":"time-series.html","id":"recapitulando-13","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"Recapitulando","text":"","code":""},{"path":"time-series.html","id":"exercícios-13","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"Exercícios","text":"","code":""},{"path":"time-series.html","id":"dicionário-de-funções-13","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"Dicionário de Funções","text":"","code":""},{"path":"time-series.html","id":"referências-13","chapter":"Capítulo 14 Manipulação de Datas e Séries de Tempo","heading":"Referências","text":"","code":""},{"path":"recap2.html","id":"recap2","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da segunda parte, falando dos fundamentos e etapas de projetos de ciência de dados, e como cada ferramenta tidyverse nos ajuda aplicá-las.","code":""},{"path":"intro3.html","id":"intro3","chapter":"Parte III - Aplicações Diversas","heading":"Parte III - Aplicações Diversas","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Bem vindo à terceira parte deste livro. Aqui, o objetivo é mostrar como aplicar os conhecimentos adquiridos nas outras duas partes, em temas comuns. Já existe uma literatura extensa com objetivos similares, portanto, foco em temas mais centrais, e/ou que tenham um alto ganho de serem abordados com os frameworks e linguagem desenvolvida neste livro.Agora sim, o estilo livro é bem mais mostrar capacidades R através de exemplos, que o estudo teórico das outras seções.Os temas são:Capítulo 15: apresento como resolver problemas comuns em probabilidade e estatística, o assunto central R.Capítulo 16: apresento como aplicar habilidades de manipulação e visualização de dados, para explorar e obter informações contidas em datasets.Capítulo 17: apresento como realizar análises de regressões, com base nos vários modelos comuns inclusos R.Capítulo 18: complementar à regressões, apresento rapidamente alguns frameworks para modelos mais complexos de machine learning.Capítulo 11.5: para servir de referência, listo outras aplicações de possível interesse, especialmente aquelas com relação aos conceitos deste livro.","code":""},{"path":"stats-prob.html","id":"stats-prob","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"Capítulo 15 Probabilidade e Estatística","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, apresentarei como resolver problemas comuns em probabilidade e estatística, o assunto central R.","code":""},{"path":"stats-prob.html","id":"probability","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"15.1 Probability","text":"","code":""},{"path":"stats-prob.html","id":"random-numbers","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"15.1.1 Random Numbers","text":"","code":""},{"path":"stats-prob.html","id":"useful-measures","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"15.1.2 Useful Measures","text":"","code":""},{"path":"stats-prob.html","id":"statistics","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"15.2 Statistics","text":"","code":""},{"path":"stats-prob.html","id":"useful-measures-1","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"15.2.1 Useful Measures","text":"","code":""},{"path":"stats-prob.html","id":"hypothesis-testing","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"15.2.2 Hypothesis Testing","text":"","code":""},{"path":"stats-prob.html","id":"complemento-14","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"Complemento","text":"","code":""},{"path":"stats-prob.html","id":"recapitulando-14","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"Recapitulando","text":"","code":""},{"path":"stats-prob.html","id":"exercícios-14","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"Exercícios","text":"","code":""},{"path":"stats-prob.html","id":"dicionário-de-funções-14","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"Dicionário de Funções","text":"","code":""},{"path":"stats-prob.html","id":"referências-14","chapter":"Capítulo 15 Probabilidade e Estatística","heading":"Referências","text":"","code":""},{"path":"exploration.html","id":"exploration","chapter":"Capítulo 16 Exploração de Dados","heading":"Capítulo 16 Exploração de Dados","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, apresentarei como aplicar habilidades de manipulação e visualização de dados, para explorar e obter informações contidas em datasets.","code":""},{"path":"exploration.html","id":"useful-visualizations","chapter":"Capítulo 16 Exploração de Dados","heading":"16.1 Useful Visualizations","text":"","code":""},{"path":"exploration.html","id":"useful-metrics","chapter":"Capítulo 16 Exploração de Dados","heading":"16.2 Useful Metrics","text":"","code":""},{"path":"exploration.html","id":"useful-graphs","chapter":"Capítulo 16 Exploração de Dados","heading":"16.3 Useful Graphs","text":"","code":""},{"path":"exploration.html","id":"complemento-15","chapter":"Capítulo 16 Exploração de Dados","heading":"Complemento","text":"","code":""},{"path":"exploration.html","id":"recapitulando-15","chapter":"Capítulo 16 Exploração de Dados","heading":"Recapitulando","text":"","code":""},{"path":"exploration.html","id":"exercícios-15","chapter":"Capítulo 16 Exploração de Dados","heading":"Exercícios","text":"","code":""},{"path":"exploration.html","id":"dicionário-de-funções-15","chapter":"Capítulo 16 Exploração de Dados","heading":"Dicionário de Funções","text":"","code":""},{"path":"exploration.html","id":"referências-15","chapter":"Capítulo 16 Exploração de Dados","heading":"Referências","text":"","code":""},{"path":"regression.html","id":"regression","chapter":"Capítulo 17 Regressão","heading":"Capítulo 17 Regressão","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, apresentarei como realizar análises de regressões, com base nos vários modelos comuns inclusos R.","code":""},{"path":"regression.html","id":"fundamentals","chapter":"Capítulo 17 Regressão","heading":"17.1 Fundamentals","text":"","code":""},{"path":"regression.html","id":"data","chapter":"Capítulo 17 Regressão","heading":"17.1.1 Data","text":"","code":""},{"path":"regression.html","id":"formulas","chapter":"Capítulo 17 Regressão","heading":"17.1.2 Formulas","text":"","code":""},{"path":"regression.html","id":"fitting","chapter":"Capítulo 17 Regressão","heading":"17.1.3 Fitting","text":"","code":""},{"path":"regression.html","id":"visualizing","chapter":"Capítulo 17 Regressão","heading":"17.1.4 Visualizing","text":"","code":""},{"path":"regression.html","id":"testing","chapter":"Capítulo 17 Regressão","heading":"17.1.5 Testing","text":"","code":""},{"path":"regression.html","id":"correcting","chapter":"Capítulo 17 Regressão","heading":"17.1.6 Correcting","text":"","code":""},{"path":"regression.html","id":"linear-models","chapter":"Capítulo 17 Regressão","heading":"17.2 Linear Models","text":"","code":""},{"path":"regression.html","id":"non-linear-models","chapter":"Capítulo 17 Regressão","heading":"17.3 Non-Linear Models","text":"","code":""},{"path":"regression.html","id":"time-series-models","chapter":"Capítulo 17 Regressão","heading":"17.4 Time-Series Models","text":"","code":""},{"path":"regression.html","id":"complemento-16","chapter":"Capítulo 17 Regressão","heading":"Complemento","text":"","code":""},{"path":"regression.html","id":"recapitulando-16","chapter":"Capítulo 17 Regressão","heading":"Recapitulando","text":"","code":""},{"path":"regression.html","id":"exercícios-16","chapter":"Capítulo 17 Regressão","heading":"Exercícios","text":"","code":""},{"path":"regression.html","id":"dicionário-de-funções-16","chapter":"Capítulo 17 Regressão","heading":"Dicionário de Funções","text":"","code":""},{"path":"regression.html","id":"referências-16","chapter":"Capítulo 17 Regressão","heading":"Referências","text":"","code":""},{"path":"ml.html","id":"ml","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"Capítulo 18 Aprendizado de Máquina","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, apresentarei rapidamente alguns frameworks para modelos mais complexos de machine learning.","code":""},{"path":"ml.html","id":"fundamentals-1","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"18.1 Fundamentals","text":"","code":""},{"path":"ml.html","id":"ml-in-built-in-r","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"18.2 ML in Built-In R","text":"","code":""},{"path":"ml.html","id":"ml-in-external-packages","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"18.3 ML in External Packages","text":"","code":""},{"path":"ml.html","id":"complemento-17","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"Complemento","text":"","code":""},{"path":"ml.html","id":"recapitulando-17","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"Recapitulando","text":"","code":""},{"path":"ml.html","id":"exercícios-17","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"Exercícios","text":"","code":""},{"path":"ml.html","id":"dicionário-de-funções-17","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"Dicionário de Funções","text":"","code":""},{"path":"ml.html","id":"referências-17","chapter":"Capítulo 18 Aprendizado de Máquina","heading":"Referências","text":"","code":""},{"path":"others3.html","id":"others3","chapter":"Capítulo 19 Outras Aplicações","heading":"Capítulo 19 Outras Aplicações","text":"Aviso: este capítulo está em construção. O que segue abaixo é apenas um rascunho.Neste capítulo, listarei outras aplicações de possível interesse, especialmente aquelas com relação aos conceitos deste livro.Alguns dos temas:Economia e finanças com tidyquant.Modelagem com tidymodels.Comunicação com RMarkdown, stargazer, broom, e Shiny.Otimização.Bioestatística e estatística geoespacial.Pacotes.","code":""},{"path":"others3.html","id":"complemento-18","chapter":"Capítulo 19 Outras Aplicações","heading":"Complemento","text":"","code":""},{"path":"others3.html","id":"recapitulando-18","chapter":"Capítulo 19 Outras Aplicações","heading":"Recapitulando","text":"","code":""},{"path":"others3.html","id":"exercícios-18","chapter":"Capítulo 19 Outras Aplicações","heading":"Exercícios","text":"","code":""},{"path":"others3.html","id":"dicionário-de-funções-18","chapter":"Capítulo 19 Outras Aplicações","heading":"Dicionário de Funções","text":"","code":""},{"path":"others3.html","id":"referências-18","chapter":"Capítulo 19 Outras Aplicações","heading":"Referências","text":"","code":""},{"path":"dict.html","id":"dict","chapter":"Dicionário de funções","heading":"Dicionário de funções","text":"Abaixo segue lista de funções vistas neste livro.","code":""},{"path":"refs.html","id":"refs","chapter":"Referências","heading":"Referências","text":"Abaixo seguem principais referências deste livro.","code":""}]
